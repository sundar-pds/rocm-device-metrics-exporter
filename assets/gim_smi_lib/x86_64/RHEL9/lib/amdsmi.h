/*
 * Copyright (c) 2022-2024 Advanced Micro Devices, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @file amdsmi.h
 *
 * AMD AMDSMI Library Types
 */

#ifndef __AMDSMI_H__
#define __AMDSMI_H__

#ifndef __KERNEL__
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#endif

/**
 * @brief Initialization flags
 *
 * Initialization flags may be OR'd together and passed to ::amdsmi_init().
 */
typedef enum {
	AMDSMI_INIT_ALL_PROCESSORS = 0xFFFFFFFF,  //!< Initialize all processors
	AMDSMI_INIT_AMD_CPUS = (1 << 0),
	AMDSMI_INIT_AMD_GPUS = (1 << 1),
	AMDSMI_INIT_NON_AMD_CPUS = (1 << 2),
	AMDSMI_INIT_NON_AMD_GPUS = (1 << 3),
	AMDSMI_INIT_AMD_APUS = (AMDSMI_INIT_AMD_CPUS | AMDSMI_INIT_AMD_GPUS) // Default option
} amdsmi_init_flags_t;

/**
 * @brief Maximum size definitions AMDSMI
 */
#define AMDSMI_MAX_DEVICES		 32
#define AMDSMI_MAX_VF_COUNT		 32
#define AMDSMI_PF_INDEX			 (AMDSMI_MAX_VF_COUNT - 1)
#define AMDSMI_MAX_STRING_LENGTH	 256
#define AMDSMI_MAX_DRIVER_INFO_RSVD	 64
#define AMDSMI_MAX_MM_IP_COUNT		 8
#define AMDSMI_MAX_CACHE_TYPES 10
#define AMDSMI_MAX_NUM_PM_POLICIES 32
#define AMDSMI_MAX_NAME 32

//! Maximum of two drv
#define AMDSMI_MAX_DRIVER_NUM		 2

//! YYYY-MM-DD:HH:MM:SS.MSC
#define AMDSMI_MAX_DATE_LENGTH		 32

#define AMDSMI_GPU_UUID_SIZE		 38

#define AMDSMI_DFC_FW_NUMBER_OF_ENTRIES  9

#define AMDSMI_MAX_WHITE_LIST_ELEMENTS 	 16
#define AMDSMI_MAX_BLACK_LIST_ELEMENTS 	 64
#define AMDSMI_MAX_UUID_ELEMENTS 	 16
#define AMDSMI_MAX_TA_WHITE_LIST_ELEMENTS 	 8

#define AMDSMI_MAX_ERR_RECORDS		 10

//! 256 BYTES
#define AMDSMI_EVENT_MSG_SIZE		 256

#define AMDSMI_MAX_PROFILE_COUNT	 16

/**
 * @brief string format
 */
#define AMDSMI_TIME_FORMAT "%02d:%02d:%02d.%03d"
#define AMDSMI_DATE_FORMAT "%04d-%02d-%02d:%02d:%02d:%02d.%03d"

/**
 * @brief AMDSMI event mask
 */

//! include all events and all severities
#define AMDSMI_MASK_ALL (~0ULL)

//! include all events but only error severities without warnings and infos
#define AMDSMI_MASK_DEFAULT ((1ULL << 62) - 1)

//! a clear event mask
#define AMDSMI_MASK_INIT (0ULL)

//! check mask in case new severity levels are not supported
#define AMDSMI_MASK_HIGH_AND_MED_SEVERITY (~((1ULL << 61) - 1))

/**
 * @brief error severity level mask
 */
#define AMDSMI_MASK_HIGH_ERROR_SEVERITY_ONLY(mask)   (mask & ((1ULL << 60) - 1))
#define AMDSMI_MASK_INCLUDE_MED_ERROR_SEVERITY(mask) (mask | (1ULL << 60))
#define AMDSMI_MASK_INCLUDE_LOW_ERROR_SEVERITY(mask) (mask | (1ULL << 61))
#define AMDSMI_MASK_INCLUDE_WARN_SEVERITY(mask) (mask | (1ULL << 62))
#define AMDSMI_MASK_INCLUDE_INFO_SEVERITY(mask) (mask | (1ULL << 63))

/**
 * @brief map old severity level mask to new severity level
 */
#define AMDSMI_MASK_HIGH_SEVERITY_ONLY(mask)   (mask & ((1ULL << 62) - 1))
#define AMDSMI_MASK_INCLUDE_MED_SEVERITY(mask) AMDSMI_MASK_INCLUDE_WARN_SEVERITY(mask)
#define AMDSMI_MASK_INCLUDE_LOW_SEVERITY(mask) AMDSMI_MASK_INCLUDE_INFO_SEVERITY(mask)

#define AMDSMI_MASK_INCLUDE_CATEGORY(mask, cate) (mask | (1ULL << cate))
#define AMDSMI_MASK_EXCLUDE_CATEGORY(mask, cate) (mask & (~(1ULL << cate)))

#define AMDSMI_MAX_NUM_XGMI_PHYSICAL_LINK 64
#define AMDSMI_MAX_FB_SHARING_GROUPS 64
#define AMDSMI_MAX_NUM_CONNECTED_NODES 64

#define AMDSMI_MAX_NUM_METRICS_V1 255
#define AMDSMI_MAX_NUM_METRICS AMDSMI_MAX_NUM_METRICS_V1

#define AMDSMI_MAX_BAD_PAGE_RECORD_V1 512
#define AMDSMI_MAX_BAD_PAGE_RECORD_V2 16384
#define AMDSMI_MAX_BAD_PAGE_RECORD AMDSMI_MAX_BAD_PAGE_RECORD_V2

#define AMDSMI_MAX_CP_PROFILE_RESOURCES  32
#define AMDSMI_MAX_ACCELERATOR_PARTITIONS 8
#define AMDSMI_MAX_ACCELERATOR_PROFILE 32
#define AMDSMI_MAX_NUM_NUMA_NODES 32

//! opaque handler point to underlying implementation
typedef void *amdsmi_socket_handle;
typedef void *amdsmi_event_set;
typedef void *amdsmi_processor_handle;

/**
 * @brief ENUMERATORS
 */
typedef enum {
	AMDSMI_STATUS_SUCCESS = 0,  //!< Call succeeded
	// Library usage errors
	AMDSMI_STATUS_INVAL = 1,  //!< Invalid parameters
	AMDSMI_STATUS_NOT_SUPPORTED = 2,  //!< Command not supported
	AMDSMI_STATUS_NOT_YET_IMPLEMENTED = 3,  //!< Not implemented yet
	AMDSMI_STATUS_FAIL_LOAD_MODULE = 4,  //!< Fail to load lib
	AMDSMI_STATUS_FAIL_LOAD_SYMBOL = 5,  //!< Fail to load symbol
	AMDSMI_STATUS_DRM_ERROR = 6,  //!< Error when call libdrm
	AMDSMI_STATUS_API_FAILED = 7,  //!< API call failed
	AMDSMI_STATUS_TIMEOUT = 8,  //!< Timeout in API call
	AMDSMI_STATUS_RETRY = 9,  //!< Retry operation
	AMDSMI_STATUS_NO_PERM = 10,  //!< Permission Denied
	AMDSMI_STATUS_INTERRUPT = 11,  //!< An interrupt occurred during execution of function
	AMDSMI_STATUS_IO = 12,  //!< I/O Error
	AMDSMI_STATUS_ADDRESS_FAULT = 13,  //!< Bad address
	AMDSMI_STATUS_FILE_ERROR = 14,  //!< Problem accessing a file
	AMDSMI_STATUS_OUT_OF_RESOURCES = 15,  //!< Not enough memory
	AMDSMI_STATUS_INTERNAL_EXCEPTION = 16,  //!< An internal exception was caught
	AMDSMI_STATUS_INPUT_OUT_OF_BOUNDS = 17,  //!< The provided input is out of allowable or safe range
	AMDSMI_STATUS_INIT_ERROR = 18,  //!< An error occurred when initializing internal data structures
	AMDSMI_STATUS_REFCOUNT_OVERFLOW = 19,  //!< An internal reference counter exceeded INT32_MAX
	AMDSMI_STATUS_MORE_DATA = 20,
	// Processor related errors
	AMDSMI_STATUS_BUSY = 30,  //!< Processor busy
	AMDSMI_STATUS_NOT_FOUND = 31,  //!< Processor not found
	AMDSMI_STATUS_NOT_INIT = 32,  //!< Processor not initialized
	AMDSMI_STATUS_NO_SLOT = 33,  //!< No more free slot
	AMDSMI_STATUS_DRIVER_NOT_LOADED = 34, //!< Processor driver not loaded
	// Data and size errors
	AMDSMI_STATUS_NO_DATA = 40,  //!< No data was found for a given input
	AMDSMI_STATUS_INSUFFICIENT_SIZE = 41,  //!< Not enough resources were available for the operation
	AMDSMI_STATUS_UNEXPECTED_SIZE = 42,  //!< An unexpected amount of data was read
	AMDSMI_STATUS_UNEXPECTED_DATA = 43,  //!< The data read or provided to function is not what was expected
	//esmi errors
	AMDSMI_STATUS_NON_AMD_CPU = 44, //!< System has different cpu than AMD
	AMDSMI_STATUS_NO_ENERGY_DRV = 45, //!< Energy driver not found
	AMDSMI_STATUS_NO_MSR_DRV = 46, //!< MSR driver not found
	AMDSMI_STATUS_NO_HSMP_DRV = 47, //!< HSMP driver not found
	AMDSMI_STATUS_NO_HSMP_SUP = 48, //!< HSMP not supported
	AMDSMI_STATUS_NO_HSMP_MSG_SUP = 49, //!< HSMP message/feature not supported
	AMDSMI_STATUS_HSMP_TIMEOUT = 50,  //!< HSMP message is timedout
	AMDSMI_STATUS_NO_DRV = 51,  //!< No Energy and HSMP driver present
	AMDSMI_STATUS_FILE_NOT_FOUND = 52, //!< file or directory not found
	AMDSMI_STATUS_ARG_PTR_NULL = 53,   //!< Parsed argument is invalid
	AMDSMI_STATUS_AMDGPU_RESTART_ERR = 54, //!< AMDGPU restart failed
	AMDSMI_STATUS_SETTING_UNAVAILABLE = 55, //!< Setting is not available

	// General errors
	AMDSMI_STATUS_MAP_ERROR = 0xFFFFFFFE,  //!< The internal library error did not map to a status code
	AMDSMI_STATUS_UNKNOWN_ERROR = 0xFFFFFFFF,  //!< An unknown error occurred
} amdsmi_status_t;

/**
 * @brief cache properties
 */
typedef enum {
	AMDSMI_CACHE_PROPERTY_ENABLED = 0x00000001,
	AMDSMI_CACHE_PROPERTY_DATA_CACHE = 0x00000002,
	AMDSMI_CACHE_PROPERTY_INST_CACHE = 0x00000004,
	AMDSMI_CACHE_PROPERTY_CPU_CACHE = 0x00000008,
	AMDSMI_CACHE_PROPERTY_SIMD_CACHE = 0x00000010,
} amdsmi_cache_property_type_t;

typedef enum {
	AMDSMI_FW_ID_SMU = 1,
	AMDSMI_FW_ID_FIRST = AMDSMI_FW_ID_SMU,
	AMDSMI_FW_ID_CP_CE,
	AMDSMI_FW_ID_CP_PFP,
	AMDSMI_FW_ID_CP_ME,
	AMDSMI_FW_ID_CP_MEC_JT1,
	AMDSMI_FW_ID_CP_MEC_JT2,
	AMDSMI_FW_ID_CP_MEC1,
	AMDSMI_FW_ID_CP_MEC2,
	AMDSMI_FW_ID_RLC,
	AMDSMI_FW_ID_SDMA0,
	AMDSMI_FW_ID_SDMA1,
	AMDSMI_FW_ID_SDMA2,
	AMDSMI_FW_ID_SDMA3,
	AMDSMI_FW_ID_SDMA4,
	AMDSMI_FW_ID_SDMA5,
	AMDSMI_FW_ID_SDMA6,
	AMDSMI_FW_ID_SDMA7,
	AMDSMI_FW_ID_VCN,
	AMDSMI_FW_ID_UVD,
	AMDSMI_FW_ID_VCE,
	AMDSMI_FW_ID_ISP,
	AMDSMI_FW_ID_DMCU_ERAM, //!< eRAM
	AMDSMI_FW_ID_DMCU_ISR,  //!< ISR
	AMDSMI_FW_ID_RLC_RESTORE_LIST_GPM_MEM,
	AMDSMI_FW_ID_RLC_RESTORE_LIST_SRM_MEM,
	AMDSMI_FW_ID_RLC_RESTORE_LIST_CNTL,
	AMDSMI_FW_ID_RLC_V,
	AMDSMI_FW_ID_MMSCH,
	AMDSMI_FW_ID_PSP_SYSDRV,
	AMDSMI_FW_ID_PSP_SOSDRV,
	AMDSMI_FW_ID_PSP_TOC,
	AMDSMI_FW_ID_PSP_KEYDB,
	AMDSMI_FW_ID_DFC,
	AMDSMI_FW_ID_PSP_SPL,
	AMDSMI_FW_ID_DRV_CAP,
	AMDSMI_FW_ID_MC,
	AMDSMI_FW_ID_PSP_BL,
	AMDSMI_FW_ID_CP_PM4,
	AMDSMI_FW_ID_RLC_P,
	AMDSMI_FW_ID_SEC_POLICY_STAGE2,
	AMDSMI_FW_ID_REG_ACCESS_WHITELIST,
	AMDSMI_FW_ID_IMU_DRAM,
	AMDSMI_FW_ID_IMU_IRAM,
	AMDSMI_FW_ID_SDMA_TH0,
	AMDSMI_FW_ID_SDMA_TH1,
	AMDSMI_FW_ID_CP_MES,
	AMDSMI_FW_ID_MES_STACK,
	AMDSMI_FW_ID_MES_THREAD1, //!< FW_ID_MES_THREAD1 = CP_MES_KIQ
	AMDSMI_FW_ID_MES_THREAD1_STACK, //! FW_ID_MES_THREAD1_STACK = MES_KIQ_STACK
	AMDSMI_FW_ID_RLX6,
	AMDSMI_FW_ID_RLX6_DRAM_BOOT,
	AMDSMI_FW_ID_RS64_ME,
	AMDSMI_FW_ID_RS64_ME_P0_DATA,
	AMDSMI_FW_ID_RS64_ME_P1_DATA,
	AMDSMI_FW_ID_RS64_PFP,
	AMDSMI_FW_ID_RS64_PFP_P0_DATA,
	AMDSMI_FW_ID_RS64_PFP_P1_DATA,
	AMDSMI_FW_ID_RS64_MEC,
	AMDSMI_FW_ID_RS64_MEC_P0_DATA,
	AMDSMI_FW_ID_RS64_MEC_P1_DATA,
	AMDSMI_FW_ID_RS64_MEC_P2_DATA,
	AMDSMI_FW_ID_RS64_MEC_P3_DATA,
	AMDSMI_FW_ID_PPTABLE,
	AMDSMI_FW_ID_PSP_SOC,
	AMDSMI_FW_ID_PSP_DBG,
	AMDSMI_FW_ID_PSP_INTF,
	AMDSMI_FW_ID_RLX6_CORE1,
	AMDSMI_FW_ID_RLX6_DRAM_BOOT_CORE1,
	AMDSMI_FW_ID_RLCV_LX7,
	AMDSMI_FW_ID_RLC_SAVE_RESTORE_LIST,
	AMDSMI_FW_ID_ASD,
	AMDSMI_FW_ID_TA_RAS,
	AMDSMI_FW_ID_XGMI,
	AMDSMI_FW_ID_RLC_SRLG,
	AMDSMI_FW_ID_RLC_SRLS,
	AMDSMI_FW_ID_SMC,
	AMDSMI_FW_ID_DMCU,
	AMDSMI_FW_ID_PSP_RAS,
	AMDSMI_FW_ID_P2S_TABLE,
	AMDSMI_FW_ID__MAX
} amdsmi_fw_block_t;

/**
 * @brief GPU Capability info
 */
typedef enum {
	AMDSMI_MM_UVD,
	AMDSMI_MM_VCE,
	AMDSMI_MM_VCN,
	AMDSMI_MM__MAX
} amdsmi_mm_ip_t;

/**
 * @brief Clock types
 */
typedef enum {
	AMDSMI_CLK_TYPE_SYS = 0x0,	//!< System clock
	AMDSMI_CLK_TYPE_FIRST = AMDSMI_CLK_TYPE_SYS,
	AMDSMI_CLK_TYPE_GFX = AMDSMI_CLK_TYPE_SYS,
	AMDSMI_CLK_TYPE_DF,		//!< Data Fabric clock (for ASICs
					//!< running on a separate clock)
	AMDSMI_CLK_TYPE_DCEF,		//!< Display Controller Engine clock
	AMDSMI_CLK_TYPE_SOC,
	AMDSMI_CLK_TYPE_MEM,
	AMDSMI_CLK_TYPE_PCIE,
	AMDSMI_CLK_TYPE_VCLK0,
	AMDSMI_CLK_TYPE_VCLK1,
	AMDSMI_CLK_TYPE_DCLK0,
	AMDSMI_CLK_TYPE_DCLK1,
	AMDSMI_CLK_TYPE__MAX = AMDSMI_CLK_TYPE_DCLK1
} amdsmi_clk_type_t;
/**
 * @brief This enumeration is used to indicate from which part of the processor a
 * temperature reading should be obtained.
 */
typedef enum {
	AMDSMI_TEMPERATURE_TYPE_EDGE,
	AMDSMI_TEMPERATURE_TYPE_FIRST = AMDSMI_TEMPERATURE_TYPE_EDGE,
	AMDSMI_TEMPERATURE_TYPE_HOTSPOT,
	AMDSMI_TEMPERATURE_TYPE_JUNCTION = AMDSMI_TEMPERATURE_TYPE_HOTSPOT,
	AMDSMI_TEMPERATURE_TYPE_VRAM,
	AMDSMI_TEMPERATURE_TYPE_HBM_0,
	AMDSMI_TEMPERATURE_TYPE_HBM_1,
	AMDSMI_TEMPERATURE_TYPE_HBM_2,
	AMDSMI_TEMPERATURE_TYPE_HBM_3,
	AMDSMI_TEMPERATURE_TYPE_PLX,
	AMDSMI_TEMPERATURE_TYPE__MAX = AMDSMI_TEMPERATURE_TYPE_PLX
} amdsmi_temperature_type_t;
/**
 * @brief Temperature Metrics.  This enum is used to identify various
 * temperature metrics. Corresponding values will be in Celcius.
 */
typedef enum {
	AMDSMI_TEMP_CURRENT = 0x0,	//!< Temperature current value.
	AMDSMI_TEMP_FIRST = AMDSMI_TEMP_CURRENT,
	AMDSMI_TEMP_MAX,		//!< Temperature max value.
	AMDSMI_TEMP_MIN,		//!< Temperature min value.
	AMDSMI_TEMP_MAX_HYST,		//!< Temperature hysteresis value for max limit.
					//!< (This is an absolute temperature, not a
					//!< delta).
	AMDSMI_TEMP_MIN_HYST,		//!< Temperature hysteresis value for min limit.
					//!< (This is an absolute temperature,
					//!<  not a delta).
	AMDSMI_TEMP_CRITICAL,		//!< Temperature critical max value, typically
					//!<  greater than corresponding temp_max values.
	AMDSMI_TEMP_CRITICAL_HYST,	//!< Temperature hysteresis value for critical
					//!<  limit. (This is an absolute temperature,
					//!<  not a delta).
	AMDSMI_TEMP_EMERGENCY,		//!< Temperature emergency max value, for chips
					//!<  supporting more than two upper temperature
					//!<  limits. Must be equal or greater than
					//!<  corresponding temp_crit values.
	AMDSMI_TEMP_EMERGENCY_HYST,	//!< Temperature hysteresis value for emergency
					//!<  limit. (This is an absolute temperature,
					//!<  not a delta).
	AMDSMI_TEMP_CRIT_MIN,		//!< Temperature critical min value, typically
					//!<  lower than corresponding temperature
					//!<  minimum values.
	AMDSMI_TEMP_CRIT_MIN_HYST,	//!< Temperature hysteresis value for critical
					//!< minimum limit. (This is an absolute
					//!< temperature, not a delta).
	AMDSMI_TEMP_OFFSET,		//!< Temperature offset which is added to the
					//!  temperature reading by the chip.
	AMDSMI_TEMP_LOWEST,		//!< Historical minimum temperature.
	AMDSMI_TEMP_HIGHEST,		//!< Historical maximum temperature.
	AMDSMI_TEMP_SHUTDOWN,		//!< Shutdown temperature.
	AMDSMI_TEMP_LAST = AMDSMI_TEMP_SHUTDOWN
} amdsmi_temperature_metric_t;


typedef enum {
	AMDSMI_PROCESSOR_TYPE_UNKNOWN = 0,
	AMDSMI_PROCESSOR_TYPE_AMD_GPU,
	AMDSMI_PROCESSOR_TYPE_AMD_CPU,
	AMDSMI_PROCESSOR_TYPE_NON_AMD_GPU,
	AMDSMI_PROCESSOR_TYPE_NON_AMD_CPU,
	AMDSMI_PROCESSOR_TYPE_AMD_CPU_CORE,
	AMDSMI_PROCESSOR_TYPE_AMD_APU
} processor_type_t;

typedef enum {
	AMDSMI_EVENT_CATEGORY_NON_USED	= 0,
	AMDSMI_EVENT_CATEGORY_DRIVER	= 1,
	AMDSMI_EVENT_CATEGORY_RESET	= 2,
	AMDSMI_EVENT_CATEGORY_SCHED	= 3,
	AMDSMI_EVENT_CATEGORY_VBIOS	= 4,
	AMDSMI_EVENT_CATEGORY_ECC	= 5,
	AMDSMI_EVENT_CATEGORY_PP	= 6,
	AMDSMI_EVENT_CATEGORY_IOV	= 7,
	AMDSMI_EVENT_CATEGORY_VF	= 8,
	AMDSMI_EVENT_CATEGORY_FW	= 9,
	AMDSMI_EVENT_CATEGORY_GPU	= 10,
	AMDSMI_EVENT_CATEGORY_GUARD	= 11,
	AMDSMI_EVENT_CATEGORY_GPUMON	= 12,
	AMDSMI_EVENT_CATEGORY_MMSCH	= 13,
	AMDSMI_EVENT_CATEGORY_XGMI	= 14,
	AMDSMI_EVENT_CATEGORY__MAX
} amdsmi_event_category_t;

/**
 * @brief Below are the error subcodes of each category.
 */
typedef enum {
	AMDSMI_EVENT_GPU_DEVICE_LOST = 0,
	AMDSMI_EVENT_GPU_NOT_SUPPORTED,
	AMDSMI_EVENT_GPU_RMA,
	AMDSMI_EVENT_GPU_NOT_INITIALIZED,
	AMDSMI_EVENT_GPU_MMSCH_ABNORMAL_STATE,
	AMDSMI_EVENT_GPU_RLCV_ABNORMAL_STATE,
	AMDSMI_EVENT_GPU_SDMA_ENGINE_BUSY,
	AMDSMI_EVENT_GPU_RLC_ENGINE_BUSY,
	AMDSMI_EVENT_GPU_GC_ENGINE_BUSY,
	AMDSMI_EVENT_GPU__MAX
} amdsmi_event_gpu_t;

typedef enum {
	AMDSMI_EVENT_DRIVER_SPIN_LOCK_BUSY = 0,
	AMDSMI_EVENT_DRIVER_ALLOC_SYSTEM_MEM_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_GFX_WORKQUEUE_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_MM_WORKQUEUE_FAIL,
	AMDSMI_EVENT_DRIVER_BUFFER_OVERFLOW,

	AMDSMI_EVENT_DRIVER_DEV_INIT_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_THREAD_FAIL,
	AMDSMI_EVENT_DRIVER_NO_ACCESS_PCI_REGION,
	AMDSMI_EVENT_DRIVER_MMIO_FAIL,
	AMDSMI_EVENT_DRIVER_INTERRUPT_INIT_FAIL,

	AMDSMI_EVENT_DRIVER_INVALID_VALUE,
	AMDSMI_EVENT_DRIVER_CREATE_MUTEX_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_TIMER_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_EVENT_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_SPIN_LOCK_FAIL,

	AMDSMI_EVENT_DRIVER_ALLOC_FB_MEM_FAIL,
	AMDSMI_EVENT_DRIVER_ALLOC_DMA_MEM_FAIL,
	AMDSMI_EVENT_DRIVER_NO_FB_MANAGER,
	AMDSMI_EVENT_DRIVER_HW_INIT_FAIL,
	AMDSMI_EVENT_DRIVER_SW_INIT_FAIL,

	AMDSMI_EVENT_DRIVER_INIT_CONFIG_ERROR,
	AMDSMI_EVENT_DRIVER_ERROR_LOGGING_FAILED,
	AMDSMI_EVENT_DRIVER_CREATE_RWLOCK_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_RWSEMA_FAIL,
	AMDSMI_EVENT_DRIVER_GET_READ_LOCK_FAIL,

	AMDSMI_EVENT_DRIVER_GET_WRITE_LOCK_FAIL,
	AMDSMI_EVENT_DRIVER_GET_READ_SEMA_FAIL,
	AMDSMI_EVENT_DRIVER_GET_WRITE_SEMA_FAIL,

	AMDSMI_EVENT_DRIVER_DIAG_DATA_INIT_FAIL,
	AMDSMI_EVENT_DRIVER_DIAG_DATA_MEM_REQ_FAIL,
	AMDSMI_EVENT_DRIVER_DIAG_DATA_VADDR_REQ_FAIL,
	AMDSMI_EVENT_DRIVER_DIAG_DATA_BUS_ADDR_REQ_FAIL,

	AMDSMI_EVENT_DRIVER_HRTIMER_START_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_DRIVER_FILE_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_DEVICE_FILE_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_DEBUGFS_FILE_FAIL,
	AMDSMI_EVENT_DRIVER_CREATE_DEBUGFS_DIR_FAIL,

	AMDSMI_EVENT_DRIVER_PCI_ENABLE_DEVICE_FAIL,
	AMDSMI_EVENT_DRIVER_FB_MAP_FAIL,
	AMDSMI_EVENT_DRIVER_DOORBELL_MAP_FAIL,
	AMDSMI_EVENT_DRIVER_PCI_REGISTER_DRIVER_FAIL,

	AMDSMI_EVENT_DRIVER_ALLOC_IOVA_ALIGN_FAIL,

	AMDSMI_EVENT_DRIVER_ROM_MAP_FAIL,
	AMDSMI_EVENT_DRIVER_FULL_ACCESS_TIMEOUT,

	AMDSMI_EVENT_DRIVER__MAX
} amdsmi_event_driver_t;

typedef enum {
	AMDSMI_EVENT_FW_CMD_ALLOC_BUF_FAIL = 0,
	AMDSMI_EVENT_FW_CMD_BUF_PREP_FAIL,
	AMDSMI_EVENT_FW_RING_INIT_FAIL,
	AMDSMI_EVENT_FW_FW_APPLY_SECURITY_POLICY_FAIL,
	AMDSMI_EVENT_FW_START_RING_FAIL,

	AMDSMI_EVENT_FW_FW_LOAD_FAIL,
	AMDSMI_EVENT_FW_EXIT_FAIL,
	AMDSMI_EVENT_FW_INIT_FAIL,
	AMDSMI_EVENT_FW_CMD_SUBMIT_FAIL,
	AMDSMI_EVENT_FW_CMD_FENCE_WAIT_FAIL,

	AMDSMI_EVENT_FW_TMR_LOAD_FAIL,
	AMDSMI_EVENT_FW_TOC_LOAD_FAIL,
	AMDSMI_EVENT_FW_RAS_LOAD_FAIL,
	AMDSMI_EVENT_FW_RAS_UNLOAD_FAIL,
	AMDSMI_EVENT_FW_RAS_TA_INVOKE_FAIL,
	AMDSMI_EVENT_FW_RAS_TA_ERR_INJECT_FAIL,

	AMDSMI_EVENT_FW_ASD_LOAD_FAIL,
	AMDSMI_EVENT_FW_ASD_UNLOAD_FAIL,
	AMDSMI_EVENT_FW_AUTOLOAD_FAIL,
	AMDSMI_EVENT_FW_VFGATE_FAIL,

	AMDSMI_EVENT_FW_XGMI_LOAD_FAIL,
	AMDSMI_EVENT_FW_XGMI_UNLOAD_FAIL,
	AMDSMI_EVENT_FW_XGMI_TA_INVOKE_FAIL,

	AMDSMI_EVENT_FW_TMR_INIT_FAIL,
	AMDSMI_EVENT_FW_NOT_SUPPORTED_FEATURE,
	AMDSMI_EVENT_FW_GET_PSP_TRACELOG_FAIL,

	AMDSMI_EVENT_FW_SET_SNAPSHOT_ADDR_FAIL,
	AMDSMI_EVENT_FW_SNAPSHOT_TRIGGER_FAIL,

	AMDSMI_EVENT_FW_MIGRATION_GET_PSP_INFO_FAIL,
	AMDSMI_EVENT_FW_MIGRATION_EXPORT_FAIL,
	AMDSMI_EVENT_FW_MIGRATION_IMPORT_FAIL,

	AMDSMI_EVENT_FW_BL_FAIL,
	AMDSMI_EVENT_FW_RAS_BOOT_FAIL,
	AMDSMI_EVENT_FW_MAILBOX_ERROR,

	AMDSMI_EVENT_FW__MAX
} amdsmi_event_fw_t;

#define AMDSMI_EVENT_FW_FW_INIT_FAIL	AMDSMI_EVENT_FW_RING_INIT_FAIL

typedef enum {
	AMDSMI_EVENT_RESET_GPU = 0,
	AMDSMI_EVENT_RESET_GPU_FAILED,
	AMDSMI_EVENT_RESET_FLR,
	AMDSMI_EVENT_RESET_FLR_FAILED,
	AMDSMI_EVENT_RESET__MAX
} amdsmi_event_reset_t;

typedef enum {
	AMDSMI_EVENT_IOV_NO_GPU_IOV_CAP = 0,
	AMDSMI_EVENT_IOV_ASIC_NO_SRIOV_SUPPORT,
	AMDSMI_EVENT_IOV_ENABLE_SRIOV_FAIL,
	AMDSMI_EVENT_IOV_CMD_TIMEOUT,
	AMDSMI_EVENT_IOV_CMD_ERROR,

	AMDSMI_EVENT_IOV_INIT_IV_RING_FAIL,
	AMDSMI_EVENT_IOV_SRIOV_STRIDE_ERROR,
	AMDSMI_EVENT_IOV_WS_SAVE_TIMEOUT,
	AMDSMI_EVENT_IOV_WS_IDLE_TIMEOUT,
	AMDSMI_EVENT_IOV_WS_RUN_TIMEOUT,
	AMDSMI_EVENT_IOV_WS_LOAD_TIMEOUT,
	AMDSMI_EVENT_IOV_WS_SHUTDOWN_TIMEOUT,
	AMDSMI_EVENT_IOV_WS_ALREADY_SHUTDOWN,
	AMDSMI_EVENT_IOV_WS_INFINITE_LOOP,
	AMDSMI_EVENT_IOV_WS_REENTRANT_ERROR,
	AMDSMI_EVENT_IOV__MAX
} amdsmi_event_iov_t;

typedef enum {
	AMDSMI_EVENT_ECC_UCE = 0,
	AMDSMI_EVENT_ECC_CE,
	AMDSMI_EVENT_ECC_IN_PF_FB,
	AMDSMI_EVENT_ECC_IN_CRI_REG,
	AMDSMI_EVENT_ECC_IN_VF_CRI,
	AMDSMI_EVENT_ECC_REACH_THD,
	AMDSMI_EVENT_ECC_VF_CE,
	AMDSMI_EVENT_ECC_VF_UE,
	AMDSMI_EVENT_ECC_IN_SAME_ROW,
	AMDSMI_EVENT_ECC_UMC_UE,
	AMDSMI_EVENT_ECC_GFX_CE,
	AMDSMI_EVENT_ECC_GFX_UE,
	AMDSMI_EVENT_ECC_SDMA_CE,
	AMDSMI_EVENT_ECC_SDMA_UE,
	AMDSMI_EVENT_ECC_GFX_CE_TOTAL,
	AMDSMI_EVENT_ECC_GFX_UE_TOTAL,
	AMDSMI_EVENT_ECC_SDMA_CE_TOTAL,
	AMDSMI_EVENT_ECC_SDMA_UE_TOTAL,
	AMDSMI_EVENT_ECC_UMC_CE_TOTAL,
	AMDSMI_EVENT_ECC_UMC_UE_TOTAL,
	AMDSMI_EVENT_ECC_MMHUB_CE,
	AMDSMI_EVENT_ECC_MMHUB_UE,
	AMDSMI_EVENT_ECC_MMHUB_CE_TOTAL,
	AMDSMI_EVENT_ECC_MMHUB_UE_TOTAL,
	AMDSMI_EVENT_ECC_XGMI_WAFL_CE,
	AMDSMI_EVENT_ECC_XGMI_WAFL_UE,
	AMDSMI_EVENT_ECC_XGMI_WAFL_CE_TOTAL,
	AMDSMI_EVENT_ECC_XGMI_WAFL_UE_TOTAL,
	AMDSMI_EVENT_ECC_FATAL_ERROR,
	AMDSMI_EVENT_ECC_POISON_CONSUMPTION,
	AMDSMI_EVENT_ECC_ACA_DUMP,
	AMDSMI_EVENT_ECC_WRONG_SOCKET_ID,
	AMDSMI_EVENT_ECC_ACA_UNKNOWN_BLOCK_INSTANCE,
	AMDSMI_EVENT_ECC_UNKNOWN_CHIPLET_CE,
	AMDSMI_EVENT_ECC_UNKNOWN_CHIPLET_UE,
	AMDSMI_EVENT_ECC_UMC_CHIPLET_CE,
	AMDSMI_EVENT_ECC_UMC_CHIPLET_UE,
	AMDSMI_EVENT_ECC_GFX_CHIPLET_CE,
	AMDSMI_EVENT_ECC_GFX_CHIPLET_UE,
	AMDSMI_EVENT_ECC_SDMA_CHIPLET_CE,
	AMDSMI_EVENT_ECC_SDMA_CHIPLET_UE,
	AMDSMI_EVENT_ECC_MMHUB_CHIPLET_CE,
	AMDSMI_EVENT_ECC_MMHUB_CHIPLET_UE,
	AMDSMI_EVENT_ECC_XGMI_WAFL_CHIPLET_CE,
	AMDSMI_EVENT_ECC_XGMI_WAFL_CHIPLET_UE,
	AMDSMI_EVENT_ECC_EEPROM_ENTRIES_FOUND,
	AMDSMI_EVENT_ECC_UMC_DE,
	AMDSMI_EVENT_ECC_UMC_DE_TOTAL,
	AMDSMI_EVENT_ECC_UNKNOWN,
	AMDSMI_EVENT_ECC_EEPROM_REACH_THD,
	AMDSMI_EVENT_ECC_UMC_CHIPLET_DE,
	AMDSMI_EVENT_ECC_UNKNOWN_CHIPLET_DE,
	AMDSMI_EVENT_ECC_EEPROM_CHK_MISMATCH,
	AMDSMI_EVENT_ECC_EEPROM_RESET,
	AMDSMI_EVENT_ECC_EEPROM_RESET_FAILED,
	AMDSMI_EVENT_ECC_EEPROM_APPEND,
	AMDSMI_EVENT_ECC_THD_CHANGED,
	AMDSMI_EVENT_ECC_DUP_ENTRIES,
	AMDSMI_EVENT_ECC_EEPROM_WRONG_HDR,
	AMDSMI_EVENT_ECC_EEPROM_WRONG_VER,

	AMDSMI_EVENT_ECC__MAX
} amdsmi_event_ecc_t;

typedef enum {
	AMDSMI_EVENT_PP_SET_DPM_POLICY_FAIL = 0,
	AMDSMI_EVENT_PP_ACTIVATE_DPM_POLICY_FAIL,
	AMDSMI_EVENT_PP_I2C_SLAVE_NOT_PRESENT,
	AMDSMI_EVENT_PP_THROTTLER_EVENT,
	AMDSMI_EVENT_PP__MAX
} amdsmi_event_pp_t;

typedef enum {
	AMDSMI_EVENT_SCHED_WORLD_SWITCH_FAIL = 0,
	AMDSMI_EVENT_SCHED_DISABLE_AUTO_HW_SWITCH_FAIL,
	AMDSMI_EVENT_SCHED_ENABLE_AUTO_HW_SWITCH_FAIL,
	AMDSMI_EVENT_SCHED_GFX_SAVE_REG_FAIL,
	AMDSMI_EVENT_SCHED_GFX_IDLE_REG_FAIL,

	AMDSMI_EVENT_SCHED_GFX_RUN_REG_FAIL,
	AMDSMI_EVENT_SCHED_GFX_LOAD_REG_FAIL,
	AMDSMI_EVENT_SCHED_GFX_INIT_REG_FAIL,
	AMDSMI_EVENT_SCHED_MM_SAVE_REG_FAIL,
	AMDSMI_EVENT_SCHED_MM_IDLE_REG_FAIL,

	AMDSMI_EVENT_SCHED_MM_RUN_REG_FAIL,
	AMDSMI_EVENT_SCHED_MM_LOAD_REG_FAIL,
	AMDSMI_EVENT_SCHED_MM_INIT_REG_FAIL,
	AMDSMI_EVENT_SCHED_INIT_GPU_FAIL,
	AMDSMI_EVENT_SCHED_RUN_GPU_FAIL,

	AMDSMI_EVENT_SCHED_SAVE_GPU_STATE_FAIL,
	AMDSMI_EVENT_SCHED_LOAD_GPU_STATE_FAIL,
	AMDSMI_EVENT_SCHED_IDLE_GPU_FAIL,
	AMDSMI_EVENT_SCHED_FINI_GPU_FAIL,
	AMDSMI_EVENT_SCHED_DEAD_VF,

	AMDSMI_EVENT_SCHED_EVENT_QUEUE_FULL,
	AMDSMI_EVENT_SCHED_SHUTDOWN_VF_FAIL,
	AMDSMI_EVENT_SCHED_RESET_VF_NUM_FAIL,
	AMDSMI_EVENT_SCHED_IGNORE_EVENT,
	AMDSMI_EVENT_SCHED_PF_SWITCH_FAIL,
	AMDSMI_EVENT_SCHED__MAX
} amdsmi_event_sched_t;

typedef enum {
	AMDSMI_EVENT_VF_ATOMBIOS_INIT_FAIL = 0,
	AMDSMI_EVENT_VF_NO_VBIOS,
	AMDSMI_EVENT_VF_GPU_POST_ERROR,
	AMDSMI_EVENT_VF_ATOMBIOS_GET_CLOCK_FAIL,
	AMDSMI_EVENT_VF_FENCE_INIT_FAIL,
	AMDSMI_EVENT_VF_AMDGPU_INIT_FAIL,
	AMDSMI_EVENT_VF_IB_INIT_FAIL,
	AMDSMI_EVENT_VF_AMDGPU_LATE_INIT_FAIL,
	AMDSMI_EVENT_VF_ASIC_RESUME_FAIL,
	AMDSMI_EVENT_VF_GPU_RESET_FAIL,
	AMDSMI_EVENT_VF__MAX
} amdsmi_event_vf_max_t;

typedef enum {
	AMDSMI_EVENT_VBIOS_INVALID = 0,
	AMDSMI_EVENT_VBIOS_IMAGE_MISSING,
	AMDSMI_EVENT_VBIOS_CHECKSUM_ERR,
	AMDSMI_EVENT_VBIOS_POST_FAIL,
	AMDSMI_EVENT_VBIOS_READ_FAIL,

	AMDSMI_EVENT_VBIOS_READ_IMG_HEADER_FAIL,
	AMDSMI_EVENT_VBIOS_READ_IMG_SIZE_FAIL,
	AMDSMI_EVENT_VBIOS_GET_FW_INFO_FAIL,
	AMDSMI_EVENT_VBIOS_GET_TBL_REVISION_FAIL,
	AMDSMI_EVENT_VBIOS_PARSER_TBL_FAIL,

	AMDSMI_EVENT_VBIOS_IP_DISCOVERY_FAIL,
	AMDSMI_EVENT_VBIOS_TIMEOUT,
	AMDSMI_EVENT_VBIOS_HASH_INVALID,
	AMDSMI_EVENT_VBIOS_HASH_UPDATED,
	AMDSMI_EVENT_VBIOS_IP_DISCOVERY_BINARY_CHECKSUM_FAIL,
	AMDSMI_EVENT_VBIOS_IP_DISCOVERY_TABLE_CHECKSUM_FAIL,
	AMDSMI_EVENT_VBIOS__MAX
} amdsmi_event_vbios_t;

typedef enum {
	AMDSMI_EVENT_GUARD_RESET_FAIL = 0,
	AMDSMI_EVENT_GUARD_EVENT_OVERFLOW,
	AMDSMI_EVENT_GUARD__MAX
} amdsmi_event_guard_t;

typedef enum {
	AMDSMI_EVENT_GPUMON_INVALID_OPTION = 0,
	AMDSMI_EVENT_GPUMON_INVALID_VF_INDEX,
	AMDSMI_EVENT_GPUMON_INVALID_FB_SIZE,
	AMDSMI_EVENT_GPUMON_NO_SUITABLE_SPACE,
	AMDSMI_EVENT_GPUMON_NO_AVAILABLE_SLOT,

	AMDSMI_EVENT_GPUMON_OVERSIZE_ALLOCATION,
	AMDSMI_EVENT_GPUMON_OVERLAPPING_FB,
	AMDSMI_EVENT_GPUMON_INVALID_GFX_TIMESLICE,
	AMDSMI_EVENT_GPUMON_INVALID_MM_TIMESLICE,
	AMDSMI_EVENT_GPUMON_INVALID_GFX_PART,

	AMDSMI_EVENT_GPUMON_VF_BUSY,
	AMDSMI_EVENT_GPUMON_INVALID_VF_NUM,
	AMDSMI_EVENT_GPUMON_NOT_SUPPORTED,
	AMDSMI_EVENT_GPUMON__MAX
} amdsmi_event_gpumon_t;

typedef enum {
	AMDSMI_EVENT_MMSCH_IGNORED_JOB = 0,
	AMDSMI_EVENT_MMSCH_UNSUPPORTED_VCN_FW,
	AMDSMI_EVENT_MMSCH__MAX
} amdsmi_event_mmsch_t;

typedef enum {
	AMDSMI_EVENT_XGMI_TOPOLOGY_UPDATE_FAILED = 0,
	AMDSMI_EVENT_XGMI_TOPOLOGY_HW_INIT_UPDATE,
	AMDSMI_EVENT_XGMI_TOPOLOGY_UPDATE_DONE,
	AMDSMI_EVENT_XGMI_FB_SHARING_SETTING_ERROR,
	AMDSMI_EVENT_XGMI_FB_SHARING_SETTING_RESET,
	AMDSMI_EVENT_XGMI__MAX
} amdsmi_event_xgmi_t;

/**
 * @brief The values of this enum are used to identify supported ecc correction schema
 */
typedef enum {
	AMDSMI_RAS_ECC_SUPPORT_PARITY = (1 << 0),
	AMDSMI_RAS_ECC_SUPPORT_CORRECTABLE = (1 << 1),
	AMDSMI_RAS_ECC_SUPPORT_UNCORRECTABLE = (1 << 2),
	AMDSMI_RAS_ECC_SUPPORT_POISON = (1 << 3)
} amdsmi_ecc_correction_schema_support_t;

/**
 * @brief The values of this enum are used to identify the various firmware
 * blocks.
 */
typedef enum {
	AMDSMI_GUEST_FW_ID_VCE = 0,
	AMDSMI_GUEST_FW_ID_UVD,
	AMDSMI_GUEST_FW_ID_MC,
	AMDSMI_GUEST_FW_ID_ME,
	AMDSMI_GUEST_FW_ID_PFP,
	AMDSMI_GUEST_FW_ID_CE,
	AMDSMI_GUEST_FW_ID_RLC,
	AMDSMI_GUEST_FW_ID_RLC_SRLC,
	AMDSMI_GUEST_FW_ID_RLC_SRLG,
	AMDSMI_GUEST_FW_ID_RLC_SRLS,
	AMDSMI_GUEST_FW_ID_MEC,
	AMDSMI_GUEST_FW_ID_MEC2,
	AMDSMI_GUEST_FW_ID_SOS,
	AMDSMI_GUEST_FW_ID_ASD,
	AMDSMI_GUEST_FW_ID_TA_RAS,
	AMDSMI_GUEST_FW_ID_TA_XGMI,
	AMDSMI_GUEST_FW_ID_SMC,
	AMDSMI_GUEST_FW_ID_SDMA,
	AMDSMI_GUEST_FW_ID_SDMA2,
	AMDSMI_GUEST_FW_ID_VCN,
	AMDSMI_GUEST_FW_ID_DMCU,
	AMDSMI_GUEST_FW_ID__MAX
} amdsmi_guest_fw_engine_id_t;

typedef enum {
	AMDSMI_VF_CONFIG_FB_SIZE_SET = 0,
	AMDSMI_VF_CONFIG_FB_OFFSET_SET,
	AMDSMI_VF_CONFIG_GFX_TIMESLICE_US_SET,
	AMDSMI_VF_CONFIG_ENG_COMPUTE_BW_SET,
	AMDSMI_VF_CONFIG_GUARD_THRESHOLD_FLR_SET,
	AMDSMI_VF_CONFIG_GUARD_THRESHOLD_EXCL_MOD_SET,
	AMDSMI_VF_CONFIG_GUARD_THRESHOLD_EXCL_TIMEOUT_SET,
	AMDSMI_VF_CONFIG_GUARD_THRESHOLD_ALL_INT_SET,
	AMDSMI_VF_CONFIG_ENG_ENCODE_BW_UVD_SET,
	AMDSMI_VF_CONFIG_ENG_ENCODE_BW_VCE_SET,
	AMDSMI_VF_CONFIG_ENG_ENCODE_BW_UVD1_SET,
	AMDSMI_VF_CONFIG_ENG_ENCODE_BW_VCN_SET,
	AMDSMI_VF_CONFIG_ENG_ENCODE_BW_VCN1_SET,
	AMDSMI_VF_CONFIG__MAX
} amdsmi_vf_config_flags_t;

typedef enum {
	AMDSMI_VF_STATE_UNAVAILABLE,
	AMDSMI_VF_STATE_AVAILABLE,
	AMDSMI_VF_STATE_ACTIVE,
	AMDSMI_VF_STATE_SUSPENDED,
	AMDSMI_VF_STATE_FULLACCESS,
	AMDSMI_VF_STATE_DEFAULT_AVAILABLE
} amdsmi_vf_sched_state_t;

typedef enum {
	AMDSMI_GUARD_EVENT_FLR,
	AMDSMI_GUARD_EVENT_EXCLUSIVE_MOD,
	AMDSMI_GUARD_EVENT_EXCLUSIVE_TIMEOUT,
	AMDSMI_GUARD_EVENT_ALL_INT,
	AMDSMI_GUARD_EVENT__MAX
} amdsmi_guard_type_t;

typedef enum {
	AMDSMI_DRIVER_LIBGV,
	AMDSMI_DRIVER_KMD,
	AMDSMI_DRIVER_AMDGPUV,
	AMDSMI_DRIVER_AMDGPU,
	AMDSMI_DRIVER_VMWGPUV,
	AMDSMI_DRIVER__MAX
} amdsmi_driver_t;

typedef enum {
	AMDSMI_GUARD_STATE_NORMAL   = 0,
	AMDSMI_GUARD_STATE_FULL     = 1,
	AMDSMI_GUARD_STATE_OVERFLOW = 2,
} amdsmi_guard_state_t;

typedef enum {
	AMDSMI_SCHED_BLOCK_GFX	 = 0x0,
	AMDSMI_SCHED_BLOCK_UVD	 = 0x1,
	AMDSMI_SCHED_BLOCK_VCE	 = 0x2,
	AMDSMI_SCHED_BLOCK_UVD1  = 0x3,
	AMDSMI_SCHED_BLOCK_VCN	 = 0x4,
	AMDSMI_SCHED_BLOCK_VCN1  = 0x5,
} amdsmi_sched_block_t;

typedef enum {
	GUEST_FW_LOAD_STATUS_OK			= 0,
	GUEST_FW_LOAD_STATUS_OBSOLETE_FW	= 1,
	GUEST_FW_LOAD_STATUS_BAD_SIG		= 2,
	GUEST_FW_LOAD_STATUS_FW_LOAD_FAIL	= 3,
	GUEST_FW_LOAD_STATUS_ERR_GENERIC	= 4
} amdsmi_guest_fw_load_status_t;


typedef enum {
	AMDSMI_LINK_STATUS_ENABLED = 0,
	AMDSMI_LINK_STATUS_DISABLED = 1,
	AMDSMI_LINK_STATUS_ERROR = 2
} amdsmi_link_status_t;

typedef enum {
	AMDSMI_LINK_TYPE_INTERNAL,
	AMDSMI_LINK_TYPE_XGMI,
	AMDSMI_LINK_TYPE_PCIE,
	AMDSMI_LINK_TYPE_NOT_APPLICABLE,
	AMDSMI_LINK_TYPE_UNKNOWN
} amdsmi_link_type_t;

typedef enum {
	AMDSMI_XGMI_FB_SHARING_MODE_CUSTOM  = 0,
	AMDSMI_XGMI_FB_SHARING_MODE_1	    = 1,
	AMDSMI_XGMI_FB_SHARING_MODE_2	    = 2,
	AMDSMI_XGMI_FB_SHARING_MODE_4	    = 4,
	AMDSMI_XGMI_FB_SHARING_MODE_8	    = 8,
	AMDSMI_XGMI_FB_SHARING_MODE_UNKNOWN = 0xFFFFFFFF
} amdsmi_xgmi_fb_sharing_mode_t;

typedef enum {
	AMDSMI_PROFILE_CAPABILITY_MEMORY = 0,		//!< memory
	AMDSMI_PROFILE_CAPABILITY_ENCODE = 1,		//!< encode engine
	AMDSMI_PROFILE_CAPABILITY_DECODE = 2,		//!< decode engine
	AMDSMI_PROFILE_CAPABILITY_COMPUTE = 3,		//!< compute engine
	AMDSMI_PROFILE_CAPABILITY__MAX,
} amdsmi_profile_capability_type_t;

typedef enum {
	AMDSMI_VRAM_TYPE_UNKNOWN = 0,
	// HBM
	AMDSMI_VRAM_TYPE_HBM = 1,
	AMDSMI_VRAM_TYPE_HBM2 = 2,
	AMDSMI_VRAM_TYPE_HBM2E = 3,
	AMDSMI_VRAM_TYPE_HBM3 = 4,
	// DDR
	AMDSMI_VRAM_TYPE_DDR2 = 10,
	AMDSMI_VRAM_TYPE_DDR3 = 11,
	AMDSMI_VRAM_TYPE_DDR4 = 12,
	// GDDR
	AMDSMI_VRAM_TYPE_GDDR1 = 17,
	AMDSMI_VRAM_TYPE_GDDR2 = 18,
	AMDSMI_VRAM_TYPE_GDDR3 = 19,
	AMDSMI_VRAM_TYPE_GDDR4 = 20,
	AMDSMI_VRAM_TYPE_GDDR5 = 21,
	AMDSMI_VRAM_TYPE_GDDR6 = 22,
	AMDSMI_VRAM_TYPE_GDDR7 = 23,
} amdsmi_vram_type_t;

typedef enum {
	AMDSMI_VRAM_VENDOR_SAMSUNG,
	AMDSMI_VRAM_VENDOR_INFINEON,
	AMDSMI_VRAM_VENDOR_ELPIDA,
	AMDSMI_VRAM_VENDOR_ETRON,
	AMDSMI_VRAM_VENDOR_NANYA,
	AMDSMI_VRAM_VENDOR_HYNIX,
	AMDSMI_VRAM_VENDOR_MOSEL,
	AMDSMI_VRAM_VENDOR_WINBOND,
	AMDSMI_VRAM_VENDOR_ESMT,
	AMDSMI_VRAM_VENDOR_MICRON,
	AMDSMI_VRAM_VENDOR_UNKNOWN
} amdsmi_vram_vendor_t;

typedef enum {
	AMDSMI_GPU_BLOCK_INVALID =	0,				//!< Used to indicate an
									//!< invalid block
	AMDSMI_GPU_BLOCK_FIRST =	(1 << 0),

	AMDSMI_GPU_BLOCK_UMC =		AMDSMI_GPU_BLOCK_FIRST,		//!< UMC block
	AMDSMI_GPU_BLOCK_SDMA =		(1 << 1),			//!< SDMA block
	AMDSMI_GPU_BLOCK_GFX =		(1 << 2),			//!< GFX block
	AMDSMI_GPU_BLOCK_MMHUB =	(1 << 3),			//!< MMHUB block
	AMDSMI_GPU_BLOCK_ATHUB =	(1 << 4),			//!< ATHUB block
	AMDSMI_GPU_BLOCK_PCIE_BIF =	(1 << 5),			//!< PCIE_BIF block
	AMDSMI_GPU_BLOCK_HDP =		(1 << 6),			//!< HDP block
	AMDSMI_GPU_BLOCK_XGMI_WAFL =	(1 << 7),			//!< XGMI block
	AMDSMI_GPU_BLOCK_DF =		(1 << 8),			//!< DF block
	AMDSMI_GPU_BLOCK_SMN =		(1 << 9),			//!< SMN block
	AMDSMI_GPU_BLOCK_SEM =		(1 << 10),			//!< SEM block
	AMDSMI_GPU_BLOCK_MP0 =		(1 << 11),			//!< MP0 block
	AMDSMI_GPU_BLOCK_MP1 =		(1 << 12),			//!< MP1 block
	AMDSMI_GPU_BLOCK_FUSE =		(1 << 13),			//!< Fuse block
	AMDSMI_GPU_BLOCK_MCA =		(1 << 14),			//!< MCA block
	AMDSMI_GPU_BLOCK_VCN =		(1 << 15),			//!< VCN block
	AMDSMI_GPU_BLOCK_JPEG =		(1 << 16),			//!< JPEG block
	AMDSMI_GPU_BLOCK_IH =		(1 << 17),			//!< IH block
	AMDSMI_GPU_BLOCK_MPIO =		(1 << 18),			//!< MPIO block
	AMDSMI_GPU_BLOCK_LAST =		AMDSMI_GPU_BLOCK_MPIO,
} amdsmi_gpu_block_t;

typedef enum {
	AMDSMI_CARD_FORM_FACTOR_PCIE,
	AMDSMI_CARD_FORM_FACTOR_OAM,
	AMDSMI_CARD_FORM_FACTOR_CEM,
	AMDSMI_CARD_FORM_FACTOR_UNKNOWN
} amdsmi_card_form_factor_t;


typedef enum {
	AMDSMI_METRIC_CATEGORY_ACC_COUNTER,
	AMDSMI_METRIC_CATEGORY_FREQUENCY,
	AMDSMI_METRIC_CATEGORY_ACTIVITY,
	AMDSMI_METRIC_CATEGORY_TEMPERATURE,
	AMDSMI_METRIC_CATEGORY_POWER,
	AMDSMI_METRIC_CATEGORY_ENERGY,
	AMDSMI_METRIC_CATEGORY_THROTTLE,
	AMDSMI_METRIC_CATEGORY_PCIE,
	AMDSMI_METRIC_CATEGORY_UNKNOWN
} amdsmi_metric_category_t;

typedef enum {
	AMDSMI_METRIC_NAME_METRIC_ACC_COUNTER,
	AMDSMI_METRIC_NAME_FW_TIMESTAMP,
	AMDSMI_METRIC_NAME_CLK_GFX,
	AMDSMI_METRIC_NAME_CLK_SOC,
	AMDSMI_METRIC_NAME_CLK_MEM,
	AMDSMI_METRIC_NAME_CLK_VCLK,
	AMDSMI_METRIC_NAME_CLK_DCLK,

	AMDSMI_METRIC_NAME_USAGE_GFX,
	AMDSMI_METRIC_NAME_USAGE_MEM,
	AMDSMI_METRIC_NAME_USAGE_MM,
	AMDSMI_METRIC_NAME_USAGE_VCN,
	AMDSMI_METRIC_NAME_USAGE_JPEG,

	AMDSMI_METRIC_NAME_VOLT_GFX,
	AMDSMI_METRIC_NAME_VOLT_SOC,
	AMDSMI_METRIC_NAME_VOLT_MEM,

	AMDSMI_METRIC_NAME_TEMP_HOTSPOT_CURR,
	AMDSMI_METRIC_NAME_TEMP_HOTSPOT_LIMIT,
	AMDSMI_METRIC_NAME_TEMP_MEM_CURR,
	AMDSMI_METRIC_NAME_TEMP_MEM_LIMIT,
	AMDSMI_METRIC_NAME_TEMP_VR_CURR,
	AMDSMI_METRIC_NAME_TEMP_SHUTDOWN,

	AMDSMI_METRIC_NAME_POWER_CURR,
	AMDSMI_METRIC_NAME_POWER_LIMIT,

	AMDSMI_METRIC_NAME_ENERGY_SOCKET,
	AMDSMI_METRIC_NAME_ENERGY_CCD,
	AMDSMI_METRIC_NAME_ENERGY_XCD,
	AMDSMI_METRIC_NAME_ENERGY_AID,
	AMDSMI_METRIC_NAME_ENERGY_MEM,

	AMDSMI_METRIC_NAME_THROTTLE_SOCKET_ACTIVE,
	AMDSMI_METRIC_NAME_THROTTLE_VR_ACTIVE,
	AMDSMI_METRIC_NAME_THROTTLE_MEM_ACTIVE,

	AMDSMI_METRIC_NAME_PCIE_BANDWIDTH,
	AMDSMI_METRIC_NAME_PCIE_L0_TO_RECOVERY_COUNT,
	AMDSMI_METRIC_NAME_PCIE_REPLAY_COUNT,
	AMDSMI_METRIC_NAME_PCIE_REPLAY_ROLLOVER_COUNT,
	AMDSMI_METRIC_NAME_PCIE_NAK_SENT_COUNT,
	AMDSMI_METRIC_NAME_PCIE_NAK_RECEIVED_COUNT,

	AMDSMI_METRIC_NAME_CLK_GFX_MAX_LIMIT,
	AMDSMI_METRIC_NAME_CLK_SOC_MAX_LIMIT,
	AMDSMI_METRIC_NAME_CLK_MEM_MAX_LIMIT,
	AMDSMI_METRIC_NAME_CLK_VCLK_MAX_LIMIT,
	AMDSMI_METRIC_NAME_CLK_DCLK_MAX_LIMIT,

	AMDSMI_METRIC_NAME_CLK_GFX_MIN_LIMIT,
	AMDSMI_METRIC_NAME_CLK_SOC_MIN_LIMIT,
	AMDSMI_METRIC_NAME_CLK_MEM_MIN_LIMIT,
	AMDSMI_METRIC_NAME_CLK_VCLK_MIN_LIMIT,
	AMDSMI_METRIC_NAME_CLK_DCLK_MIN_LIMIT,

	AMDSMI_METRIC_NAME_CLK_GFX_LOCKED,

	AMDSMI_METRIC_NAME_CLK_GFX_DS_DISABLED,
	AMDSMI_METRIC_NAME_CLK_MEM_DS_DISABLED,
	AMDSMI_METRIC_NAME_CLK_SOC_DS_DISABLED,
	AMDSMI_METRIC_NAME_CLK_VCLK_DS_DISABLED,
	AMDSMI_METRIC_NAME_CLK_DCLK_DS_DISABLED,

	AMDSMI_METRIC_NAME_PCIE_LINK_SPEED,
	AMDSMI_METRIC_NAME_PCIE_LINK_WIDTH,

	AMDSMI_METRIC_NAME_DRAM_BANDWIDTH,
	AMDSMI_METRIC_NAME_MAX_DRAM_BANDWIDTH,

	AMDSMI_METRIC_NAME_UNKNOWN
} amdsmi_metric_name_t;

typedef enum {
	AMDSMI_METRIC_UNIT_COUNTER,
	AMDSMI_METRIC_UNIT_UINT,
	AMDSMI_METRIC_UNIT_BOOL,
	AMDSMI_METRIC_UNIT_MHZ,
	AMDSMI_METRIC_UNIT_PERCENT,
	AMDSMI_METRIC_UNIT_MILLIVOLT,
	AMDSMI_METRIC_UNIT_CELSIUS,
	AMDSMI_METRIC_UNIT_WATT,
	AMDSMI_METRIC_UNIT_JOULE,
	AMDSMI_METRIC_UNIT_GBPS,
	AMDSMI_METRIC_UNIT_MBITPS,
	AMDSMI_METRIC_UNIT_PCIE_GEN,
	AMDSMI_METRIC_UNIT_PCIE_LANES,
	AMDSMI_METRIC_UNIT_UNKNOWN
} amdsmi_metric_unit_t;

typedef enum {
	AMDSMI_METRIC_TYPE_COUNTER = (1 << 0), //!< counter metric
	AMDSMI_METRIC_TYPE_CHIPLET = (1 << 1), //!< chiplet metric
	AMDSMI_METRIC_TYPE_INST = (1 << 2), //!< instantaneous metric
	AMDSMI_METRIC_TYPE_ACC = (1 << 3)  //!< accumulated metric
} amdsmi_metric_type_t;

/**
 * @brief Memory Partitions. This enum is used to identify various
 * memory partition types.
 */
typedef enum {
	AMDSMI_MEMORY_PARTITION_UNKNOWN = 0,
	AMDSMI_MEMORY_PARTITION_NPS1 = 1,  //!< NPS1 - All CCD & XCD data is interleaved
							//!< across all 8 HBM stacks (all stacks/1).
	AMDSMI_MEMORY_PARTITION_NPS2 = 2,  //!< NPS2 - 2 sets of CCDs or 4 XCD interleaved
							//!< across the 4 HBM stacks per AID pair
							//!< (8 stacks/2).
	AMDSMI_MEMORY_PARTITION_NPS4 = 4,  //!< NPS4 - Each XCD data is interleaved across
							//!< across 2 (or single) HBM stacks
							//!< (8 stacks/8 or 8 stacks/4).
	AMDSMI_MEMORY_PARTITION_NPS8 = 8,  //!< NPS8 - Each XCD uses a single HBM stack
							//!< (8 stacks/8). Or each XCD uses a single
							//!< HBM stack & CCDs share 2 non-interleaved
							//!< HBM stacks on its AID
							//!< (AID[1,2,3] = 6 stacks/6).
} amdsmi_memory_partition_type_t;

typedef enum {
	AMDSMI_ACCELERATOR_PARTITION_INVALID = 0,
	AMDSMI_ACCELERATOR_PARTITION_SPX,        //!< Single GPU mode (SPX)- All XCCs work
										//!< together with shared memory
	AMDSMI_ACCELERATOR_PARTITION_DPX,        //!< Dual GPU mode (DPX)- Half XCCs work
										//!< together with shared memory
	AMDSMI_ACCELERATOR_PARTITION_TPX,        //!< Triple GPU mode (TPX)- One-third XCCs
										//!< work together with shared memory
	AMDSMI_ACCELERATOR_PARTITION_QPX,        //!< Quad GPU mode (QPX)- Quarter XCCs
										//!< work together with shared memory
	AMDSMI_ACCELERATOR_PARTITION_CPX,        //!< Core mode (CPX)- Per-chip XCC with
										//!< shared memory
	AMDSMI_ACCELERATOR_PARTITION_MAX
} amdsmi_accelerator_partition_type_t;

typedef enum {
	AMDSMI_ACCELERATOR_XCC,
	AMDSMI_ACCELERATOR_ENCODER,
	AMDSMI_ACCELERATOR_DECODER,
	AMDSMI_ACCELERATOR_DMA,
	AMDSMI_ACCELERATOR_JPEG,
	AMDSMI_ACCELERATOR_MAX
} amdsmi_accelerator_partition_resource_type_t;

typedef enum {
	AMDSMI_DRIVER_MODEL_TYPE_WDDM = 0,
	AMDSMI_DRIVER_MODEL_TYPE_WDM  = 1,
	AMDSMI_DRIVER_MODEL_TYPE_MCDM = 2,
	AMDSMI_DRIVER_MODEL_TYPE__MAX = 3,
} amdsmi_driver_model_type_t;

/**
 * @brief AUX STRUCTURES
 */

typedef union {
	struct bdf_ {
		uint64_t function_number : 3;
		uint64_t device_number : 5;
		uint64_t bus_number : 8;
		uint64_t domain_number : 48;
	} bdf;
	uint64_t as_uint;
} amdsmi_bdf_t;

typedef struct {
	struct pcie_static_ {
		uint16_t max_pcie_width; //!< maximum number of PCIe lanes
		uint32_t max_pcie_speed; //!< maximum PCIe speed
		uint32_t pcie_interface_version; //!< PCIe interface version
		amdsmi_card_form_factor_t slot_type; //!< card form factor
		uint32_t max_pcie_interface_version; //!< maximum PCIe link generation
		uint64_t reserved[9];
	} pcie_static;
	struct pcie_metric_ {
		uint16_t pcie_width; //!< current PCIe width
		uint32_t pcie_speed; //!< current PCIe speed in MT/s
		uint32_t pcie_bandwidth; //!< current PCIe bandwidth in Mb/s
		uint64_t pcie_replay_count; //!< total number of the replays issued on the PCIe link
		uint64_t pcie_l0_to_recovery_count; //!< total number of times the PCIe link transitioned from L0 to the recovery state
		uint64_t pcie_replay_roll_over_count; //!< total number of replay rollovers issued on the PCIe link
		uint64_t pcie_nak_sent_count; //!< total number of NAKs issued on the PCIe link by the device
		uint64_t pcie_nak_received_count; //!< total number of NAKs issued on the PCIe link by the receiver
		uint32_t pcie_lc_perf_other_end_recovery_count;  //!< PCIe other end recovery counter
		uint64_t reserved[12];
	} pcie_metric;
	uint64_t reserved[32];
} amdsmi_pcie_info_t;


typedef struct {
	uint64_t power_cap;
	uint64_t default_power_cap;
	uint64_t dpm_cap;
	uint64_t min_power_cap;
	uint64_t max_power_cap;
	uint64_t reserved[3];
} amdsmi_power_cap_info_t;

typedef struct {
	char name[AMDSMI_MAX_STRING_LENGTH];
	char build_date[AMDSMI_MAX_DATE_LENGTH];
	char part_number[AMDSMI_MAX_STRING_LENGTH];
	char version[AMDSMI_MAX_STRING_LENGTH];
	uint64_t reserved[68];
} amdsmi_vbios_info_t;

typedef struct {
	uint32_t num_cache_types;
	struct cache_ {
		uint32_t cache_properties;
		uint32_t cache_size; /* In KB */
		uint32_t cache_level;
		uint32_t max_num_cu_shared; /* Indicates how many Compute Units share this cache instance */
		uint32_t num_cache_instance; /* total number of instance of this cache type */
		uint32_t reserved[3];
	} cache[AMDSMI_MAX_CACHE_TYPES];
	uint32_t reserved[15];
} amdsmi_gpu_cache_info_t;

typedef struct {
	uint8_t num_fw_info;
	struct {
		amdsmi_fw_block_t fw_id;
		uint64_t fw_version;
		uint64_t reserved[2];
	} fw_info_list[AMDSMI_FW_ID__MAX];
	uint64_t reserved[7];
} amdsmi_fw_info_t;

typedef struct {
	char market_name[AMDSMI_MAX_STRING_LENGTH];
	char vendor_name[AMDSMI_MAX_STRING_LENGTH];
	char asic_serial[AMDSMI_MAX_STRING_LENGTH];
	uint64_t reserved[64];
	uint32_t vendor_id;	//!< Use 32 bit to be compatible with other platform.
	uint32_t subvendor_id;	//!< The subsystem vendor id
	uint64_t device_id;	//!< The unique id of a GPU
	uint32_t rev_id;
	uint32_t oam_id;
	uint32_t num_of_compute_units;   //< 0xFFFFFFFF if not supported
	uint64_t target_graphics_version;  //< 0xFFFFFFFFFFFFFFFF if not supported
	uint32_t subsystem_id;	//!< The subsystem device id
	uint64_t reserved_2[10];
} amdsmi_asic_info_t;

typedef struct {
	char driver_version[AMDSMI_MAX_STRING_LENGTH];
	char driver_date[AMDSMI_MAX_DATE_LENGTH];
	char driver_name[AMDSMI_MAX_STRING_LENGTH];
	uint64_t reserved[68];
} amdsmi_driver_info_t;

typedef struct {
	uint64_t socket_power;
	uint64_t gfx_voltage; //!< GFX voltage measurement in mV
	uint64_t soc_voltage; //!< SOC voltage measurement in mV
	uint64_t mem_voltage; //!< MEM voltage measurement in mV
	uint64_t reserved[4];
} amdsmi_power_info_t;

typedef struct {
	uint32_t gfx_activity;
	uint32_t umc_activity;
	uint32_t mm_activity;
	uint64_t reserved[6];
} amdsmi_engine_usage_t;

typedef struct {
	uint32_t clk;
	uint32_t min_clk;
	uint32_t max_clk;
	uint8_t clk_locked;
	uint8_t clk_deep_sleep;
	uint64_t reserved[2];
} amdsmi_clk_info_t;

typedef struct {
	uint64_t correctable_count;	//!< Accumulated correctable errors
	uint64_t uncorrectable_count;	//!< Accumulated uncorrectable errors
	uint64_t deferred_count;	//!< Accumulated deferred errors
	uint64_t reserved[5];
} amdsmi_error_count_t;

typedef struct {
	uint32_t ras_eeprom_version;
	uint32_t supported_ecc_correction_schema; //!< ecc_correction_schema mask used with amdsmi_ecc_correction_schema_support_t flags
	uint64_t reserved[3];
} amdsmi_ras_feature_t;

typedef struct {
	uint64_t handle;
} amdsmi_vf_handle_t;

typedef struct {
	amdsmi_vf_handle_t	fcn_id;
	uint64_t		dev_id;
	uint64_t		timestamp; //!< UTC microseconds
	uint64_t		data;
	uint32_t		category;
	uint32_t		subcode;
	uint32_t		level;
	char			date[AMDSMI_MAX_DATE_LENGTH]; //!< UTC date and time
	char			message[AMDSMI_EVENT_MSG_SIZE];
	uint64_t		reserved[6];
} amdsmi_event_entry_t;

typedef struct {
	char  model_number[AMDSMI_MAX_STRING_LENGTH];
	char  product_serial[AMDSMI_MAX_STRING_LENGTH];
	char  fru_id[AMDSMI_MAX_STRING_LENGTH];
	char  product_name[AMDSMI_MAX_STRING_LENGTH];
	char  manufacturer_name[AMDSMI_MAX_STRING_LENGTH];
	uint64_t reserved[64];
} amdsmi_board_info_t;

typedef struct {
	uint32_t total_fb_size;	 /**< Total GPU fb size in MB */
	uint32_t pf_fb_reserved; /**< Total fb consumed by PF */
	uint32_t pf_fb_offset;	 /**< PF FB offset */
	uint32_t fb_alignment;	 /**< FB alignment */
	uint32_t max_vf_fb_usable;	/**< Maximum usable fb size in MB */
	uint32_t min_vf_fb_usable;	/**< Minimum usable fb size in MB */
	uint64_t reserved[5];
} amdsmi_pf_fb_info_t;

typedef struct {
	uint32_t fb_offset; /**< Offset in MB from start of the framebuffer */
	uint32_t fb_size;   /**< Size in MB Must be divisible by 16 and not less than 256 */
	uint64_t reserved[3];
} amdsmi_vf_fb_info_t;

typedef struct {
	amdsmi_vf_handle_t id;
	amdsmi_vf_fb_info_t fb;
	uint64_t reserved[3];
} amdsmi_partition_info_t;

typedef struct {
	uint8_t enabled;
	struct {
		amdsmi_guard_state_t state;
		/* amount of monitor event after enabled */
		uint32_t amount;
		/* threshold of events in the interval(seconds) */
		uint64_t interval;
		uint32_t threshold;
		/* current number of events in the interval*/
		uint32_t active;
		uint32_t reserved[4];
	} guard[AMDSMI_GUARD_EVENT__MAX];
	uint32_t reserved[6];
} amdsmi_guard_info_t;

typedef struct {
	amdsmi_vf_fb_info_t fb;
	uint32_t gfx_timeslice; /**< Graphics timeslice in us, maximum value is 1000 ms*/
	uint64_t reserved[27];
} amdsmi_vf_info_t;

typedef struct {
	uint64_t		flr_count;
	uint64_t		boot_up_time; //!< in microseconds
	uint64_t		shutdown_time;
	uint64_t		reset_time;
	amdsmi_vf_sched_state_t state;
	char			last_boot_start[AMDSMI_MAX_DATE_LENGTH];
	char			last_boot_end[AMDSMI_MAX_DATE_LENGTH];
	char			last_shutdown_start[AMDSMI_MAX_DATE_LENGTH];
	char			last_shutdown_end[AMDSMI_MAX_DATE_LENGTH];
	char			last_reset_start[AMDSMI_MAX_DATE_LENGTH];
	char			last_reset_end[AMDSMI_MAX_DATE_LENGTH];
	char			current_active_time[AMDSMI_MAX_DATE_LENGTH]; //!< Current session VF time, reset after guest reload
	char			current_running_time[AMDSMI_MAX_DATE_LENGTH];
	char			total_active_time[AMDSMI_MAX_DATE_LENGTH]; /**< Cumulate across entire server lifespan, reset after host reload */
	char			total_running_time[AMDSMI_MAX_DATE_LENGTH]; /**< Not implemented */
	uint64_t reserved[11];
} amdsmi_sched_info_t;

typedef struct {
	amdsmi_sched_info_t sched;
	amdsmi_guard_info_t guard;
	uint64_t reserved[8];
} amdsmi_vf_data_t;

typedef struct {
	uint64_t total;
	uint64_t available;
	uint64_t optimal;
	uint64_t min_value;
	uint64_t max_value;
	uint64_t reserved[2];
} amdsmi_profile_caps_info_t;

typedef struct {
	uint8_t profile_count;
	uint8_t current_profile_index;
	struct {
		uint32_t vf_count;
		amdsmi_profile_caps_info_t profile_caps[AMDSMI_PROFILE_CAPABILITY__MAX];
	} profiles[AMDSMI_MAX_PROFILE_COUNT];
	uint32_t reserved[6];
} amdsmi_profile_info_t;

typedef struct {
	char driver_version[AMDSMI_MAX_DRIVER_INFO_RSVD];
	uint32_t fb_usage; /**<  guest framebuffer usage in MB */
	uint64_t reserved[23];
} amdsmi_guest_data_t;

typedef struct {
	uint32_t dfc_fw_version;
	uint32_t dfc_fw_total_entries;
	uint32_t dfc_gart_wr_guest_min;
	uint32_t dfc_gart_wr_guest_max;
	uint32_t reserved[12];
} amdsmi_dfc_fw_header_t;

typedef struct {
	uint32_t oldest;
	uint32_t latest;
} amdsmi_dfc_fw_white_list_t;

typedef struct {
	uint8_t ta_uuid[AMDSMI_MAX_UUID_ELEMENTS];
} amdsmi_dfc_fw_ta_uuid_t;

typedef struct {
	uint32_t dfc_fw_type;
	uint32_t verification_enabled;
	uint32_t customer_ordinal;
	uint32_t reserved[13];
	union {
		amdsmi_dfc_fw_white_list_t white_list[AMDSMI_MAX_WHITE_LIST_ELEMENTS];
		amdsmi_dfc_fw_ta_uuid_t ta_white_list[AMDSMI_MAX_TA_WHITE_LIST_ELEMENTS];
	};
	uint32_t black_list[AMDSMI_MAX_BLACK_LIST_ELEMENTS];
} amdsmi_dfc_fw_data_t;

typedef struct {
	amdsmi_dfc_fw_header_t header;
	amdsmi_dfc_fw_data_t data[AMDSMI_DFC_FW_NUMBER_OF_ENTRIES];
} amdsmi_dfc_fw_t;

typedef struct {
	uint64_t  retired_page; //!< Bad page frame address
	uint64_t ts;
	unsigned char err_type;
	union {
		unsigned char bank;
		unsigned char cu;
	};
	unsigned char mem_channel;
	unsigned char mcumc_id;
	uint32_t reserved[3];
} amdsmi_eeprom_table_record_t;

typedef struct {
	uint64_t timestamp;     //!< UTC microseconds
	uint32_t vf_idx;
	uint32_t fw_id;
	uint16_t status;        /**< amdsmi_guest_fw_load_status */
	uint32_t reserved[3];
} amdsmi_fw_load_error_record_t;

typedef struct {
	uint8_t num_err_records;
	amdsmi_fw_load_error_record_t err_records[AMDSMI_MAX_ERR_RECORDS];
	uint64_t reserved[7];
} amdsmi_fw_error_record_t;

typedef struct {
	uint32_t num_links; //!< number of links
	struct links_ {
		amdsmi_bdf_t bdf;
		uint32_t bit_rate; //!< current link speed in Gb/s
		uint32_t max_bandwidth; //!< max bandwidth of the link
		amdsmi_link_type_t link_type; //!< type of the link
		uint64_t read; //!< total data received for each link in KB
		uint64_t write; //!< total data transfered for each link in KB
		uint64_t reserved[2];
	} links[AMDSMI_MAX_NUM_XGMI_PHYSICAL_LINK];
	uint64_t reserved[7];
} amdsmi_link_metrics_t;

typedef struct {
	uint64_t weight; //!< link weight
	amdsmi_link_status_t link_status; //!< HW status of the link
	amdsmi_link_type_t link_type; //!< type of the link
	uint8_t  num_hops; //!< number of hops
	uint8_t  fb_sharing; //!< framebuffer sharing flag
	uint32_t reserved[10];
} amdsmi_link_topology_t;

typedef struct {
    uint32_t count;
    amdsmi_processor_handle processor_list[AMDSMI_MAX_DEVICES];
    uint64_t reserved[15];
} amdsmi_topology_nearest_t;

typedef union {
	struct cap_ {
		uint32_t mode_custom_cap :1;
		uint32_t mode_1_cap      :1;
		uint32_t mode_2_cap      :1;
		uint32_t mode_4_cap      :1;
		uint32_t mode_8_cap      :1;
		uint32_t reserved        :27;
	} cap;
	uint32_t xgmi_fb_sharing_cap_mask;
} amdsmi_xgmi_fb_sharing_caps_t;

typedef struct {
	amdsmi_vram_type_t vram_type;
	amdsmi_vram_vendor_t vram_vendor;
	uint32_t vram_size; //!< vram size in MB
	uint32_t vram_bit_width;
	uint64_t reserved[6];
} amdsmi_vram_info_t;

typedef struct {
	amdsmi_metric_unit_t unit;
	amdsmi_metric_name_t name;
	amdsmi_metric_category_t category;
	uint32_t flags;		//!< used to determine type of the metric (amdsmi_metric_type_t)
	uint32_t vf_mask;	//!< Mask of all active VFs + PF that this metric applies to
	uint64_t val;
	uint32_t reserved[8];
} amdsmi_metric_t;

/**
 * @brief This structure holds version information.
 */
typedef struct {
	uint32_t major;     //!< Major version
	uint32_t minor;     //!< Minor version
	uint32_t release;   //!< Patch, build or stepping version
} amdsmi_version_t;

/**
 * @brief This union holds memory partition bitmask.
 */
typedef union {
	struct nps_flags_{
		uint32_t nps1_cap :1; // bool 1 = true; 0 = false;
		uint32_t nps2_cap :1; // bool 1 = true; 0 = false;
		uint32_t nps4_cap :1; // bool 1 = true; 0 = false;
		uint32_t nps8_cap :1; // bool 1 = true; 0 = false;
		uint32_t reserved :28; // bool 1 = true; 0 = false;
	} nps_flags;
	uint32_t nps_cap_mask;
} amdsmi_nps_caps_t;

typedef struct {
	amdsmi_nps_caps_t partition_caps;
	amdsmi_memory_partition_type_t mp_mode;
	uint32_t num_numa_ranges;
	struct numa_range_ {
		amdsmi_vram_type_t memory_type;
		uint64_t start;
		uint64_t end;
	} numa_range[AMDSMI_MAX_NUM_NUMA_NODES];
	uint64_t reserved[11];
} amdsmi_memory_partition_config_t;

typedef struct {
	amdsmi_accelerator_partition_type_t  profile_type;	//!< SPX, DPX, QPX, CPX and so on
	uint32_t num_partitions;				//!< On MI300X, SPX: 1, DPX: 2, QPX: 4, CPX: 8
	amdsmi_nps_caps_t memory_caps;				//!< Memory capabilities of the profile
	uint32_t profile_index;					//!< The index in the profiles array in amdsmi_accelerator_partition_profile_t
	uint32_t num_resources;					//!< length of array resources
	uint32_t resources[AMDSMI_MAX_ACCELERATOR_PARTITIONS][AMDSMI_MAX_CP_PROFILE_RESOURCES];
	uint64_t reserved[13];
} amdsmi_accelerator_partition_profile_t;

typedef struct {
	uint32_t profile_index;
	amdsmi_accelerator_partition_resource_type_t resource_type;
	uint32_t partition_resource;					//!< The resources a partition can be used, which may be shared
	uint32_t num_partitions_share_resource;				//!< If it is greater than 1, then resource is shared.
	uint64_t reserved[6];
} amdsmi_accelerator_partition_resource_profile_t;

typedef struct {
	uint32_t num_profiles;	//!< The length of profiles array
	uint32_t num_resource_profiles;
	amdsmi_accelerator_partition_resource_profile_t resource_profiles[AMDSMI_MAX_CP_PROFILE_RESOURCES];
	uint32_t default_profile_index;	//!< The index of the default profile in the profiles array
	amdsmi_accelerator_partition_profile_t profiles[AMDSMI_MAX_ACCELERATOR_PROFILE];
	uint64_t reserved[30];
} amdsmi_accelerator_partition_profile_config_t;

typedef struct {
	uint32_t policy_id;
	char policy_description[AMDSMI_MAX_NAME];
	uint64_t reserved[3];
} amdsmi_dpm_policy_entry_t;

typedef struct {
	/**
	 * The number of supported policies
	 */
	uint32_t num_supported;

	/**
	 * The current policy index
	 */
	uint32_t cur;

	/**
	 * List of policies.
	 * Only the first num_supported policies are valid.
	 */
	amdsmi_dpm_policy_entry_t policies[AMDSMI_MAX_NUM_PM_POLICIES];
	uint64_t reserved[7];
} amdsmi_dpm_policy_t;

#pragma pack(push, 1)

typedef struct {
    unsigned char b[16];
} amdsmi_cper_guid_t;

typedef enum {
    AMDSMI_CPER_SEV_NON_FATAL_UNCORRECTED = 0,
    AMDSMI_CPER_SEV_FATAL                 = 1,
    AMDSMI_CPER_SEV_NON_FATAL_CORRECTED   = 2,
    AMDSMI_CPER_SEV_NUM                   = 3,

    AMDSMI_CPER_SEV_UNUSED = 10,
} amdsmi_cper_sev_t;

typedef struct {
    uint8_t seconds;
    uint8_t minutes;
    uint8_t hours;
    uint8_t flag;
    uint8_t day;
    uint8_t month;
    uint8_t year;
    uint8_t century;
} amdsmi_cper_timestamp_t;

typedef struct {
    char                     signature[4];  /* "CPER"  */
    uint16_t                 revision;
    uint32_t                 signature_end; /* 0xFFFFFFFF */
    uint16_t                 sec_cnt;
    amdsmi_cper_sev_t error_severity;
    union {
        struct {
            uint32_t platform_id  : 1;
            uint32_t timestamp    : 1;
            uint32_t partition_id : 1;
            uint32_t reserved     : 29;
        } valid_bits;
        uint32_t valid_mask;
    };
    uint32_t              record_length;    /* Total size of CPER Entry */
    amdsmi_cper_timestamp_t timestamp;
    char                  platform_id[16];
    amdsmi_cper_guid_t      partition_id;     /* Reserved */
    char                  creator_id[16];
    amdsmi_cper_guid_t      notify_type;      /* CMC, MCE */
    char                  record_id[8];     /* Unique CPER Entry ID */
    uint32_t              flags;            /* Reserved */
    uint64_t              persistence_info; /* Reserved */
    uint8_t               reserved[12];     /* Reserved */
} amdsmi_cper_hdr_t;

#pragma pack(pop)

typedef struct {
    uint8_t is_iolink_coherent; //!< 1 = true, 0 = false, UINT8_MAX = Not defined.
    uint8_t is_iolink_atomics_32bit;
    uint8_t is_iolink_atomics_64bit;
    uint8_t is_iolink_dma;
    uint8_t is_iolink_bi_directional;
    uint64_t reserved[3];
} amdsmi_p2p_capability_t;

/*****************************************************************************/
/** @defgroup init Library Initialization
 *  @{
 */

/**
 *  @brief Initializes the library and the internal software
 *  structures.
 *
 *  @note The library will attempt to initialize all AMD GPU devices
 *  in the system with virtualization support, but this may fail
 *  if the library is called from a user without sufficient
 *  privileges.
 *  The library will attempt to initialize in privileged mode
 *  or initialize in non-privileged mode as a fallback.
 *  Privileged mode can modify the driver configuration.
 *
 *  @param[in] init_flags Bit flags that tell AMDSMI how to initialize. Values of
 *  amdsmi_init_flags_t enum may be OR'd together and passed through init_flags parameter
 *  to modify how AMDSMI initializes.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_init(uint64_t init_flags);

/**
 *  @brief The library frees all associated with the library on the
 *  current process.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_shut_down(void);

/** @} */  // end of init

/*****************************************************************************/
/** @defgroup discovery Processor Discovery
 *  @{
 */

/**
 *  @brief Returns a list of AMD GPU devices in the system.
 *
 *  @note This function fills the user-provided buffer with
 *  GPU device handles. The processor handles returned are used
 *  to instantiate the rest of processor queries in the library.
 *  If the buffer is not large enough the call will fail.
 *
 *  @param[in] socket_handle The socket to query.
 *
 *  @param[inout] processor_count As input, the size of the provided buffer.
 *  As output, number of processor handles in the buffer.
 *  Parameter must be allocated by user.
 *
 *  @param[out] processor_handles Reference to list of processor handles returned by
 *  the library. Buffer must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_processor_handles(amdsmi_socket_handle socket_handle, uint32_t *processor_count, amdsmi_processor_handle *processor_handles);

/**
 *  @brief Get the processor type
 *
 *  @details Given a processor handle @p processor_handle, this function will get
 *  its processor type.
 *
 *  @param[in] processor_handle a processor handle
 *
 *  @param[out] processor_type a pointer to processor_type_t to which the processor type
 *  will be written. If this parameter is nullptr, this function will return
 *  ::AMDSMI_STATUS_INVAL.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 *
 */
amdsmi_status_t amdsmi_get_processor_type(amdsmi_processor_handle processor_handle,
				processor_type_t *processor_type);

/**
 *  @brief Returns a list of socket handles in the system.
 *  NOT SUPPORTED YET, CURRENTLY HARDCODED TO RETURN EMPTY LIST.
 *
 *  @param[in,out] socket_count As input, the size of the provided buffer.
 *  As output, number of socket handles in the buffer.
 *  Parameter must be allocated by user.
 *
 *  @param[out] socket_handles Reference to list of socket handles returned by
 *  the library. Buffer must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_socket_handles(uint32_t *socket_count, amdsmi_socket_handle *socket_handles);

/**
 *  @brief Returns socket information about given socket handle
 *  NOT SUPPORTED YET, CURRENTLY HARDCODED TO RETURN EMPTY VALUES.
 *
 *  @param[in] socket_handle socket for which to query
 *
 *  @param[in] len size of the allocated character array for the name of the socket
 *
 *  @param[out] name Reference to character array representing name of the socket returned by
 *  the library. Character array must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_socket_info(amdsmi_socket_handle socket_handle, size_t len, char *name);

/**
 *  @brief Returns processor handle (PF) from the given BDF
 *
 *  @param[in] bdf BDF of the processor
 *
 *  @param[out] processor_handle Reference to the processor handle.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_processor_handle_from_bdf(amdsmi_bdf_t bdf, amdsmi_processor_handle *processor_handle);

/**
 *  @brief Returns the index of the given processor handle
 *
 *  @param[in] processor_handle Processor handle for which to query
 *
 *  @param[out] processor_index Pointer to integer to store the processor index. Must be
 *  allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_index_from_processor_handle(amdsmi_processor_handle processor_handle, uint32_t *processor_index);

/**
 *  @brief Returns VF handle from the given BDF
 *
 *  @param[in] bdf BDF of the VF
 *
 *  @param[out] vf_handle Reference to the VF handle.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_vf_handle_from_bdf(amdsmi_bdf_t bdf, amdsmi_vf_handle_t *vf_handle);

/**
 *  @brief Returns BDF of the given processor (PF or VF).
 *
 *  @param[in] processor_handle PF or VF for which to query
 *
 *  @param[out] bdf Reference to BDF. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_device_bdf(amdsmi_processor_handle processor_handle, amdsmi_bdf_t *bdf);

/**
 *  @brief Returns the processor handle from the given processor index
 *
 *  @param[in] processor_index Function processor_index to query
 *
 *  @param[out] processor_handle Reference to the processor handle.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_processor_handle_from_index(uint32_t processor_index, amdsmi_processor_handle *processor_handle);

/**
 *  @brief Returns BDF of the given device (VF).
 *
 *  @param[in] vf_handle VF for which to query
 *
 *  @param[out] bdf Reference to BDF. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_vf_bdf(amdsmi_vf_handle_t vf_handle, amdsmi_bdf_t *bdf);

/**
 *  @brief Returns the handle of a virtual function given its index
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] fcn_idx Function index to query
 *
 *  @param[out] vf_handle VF handle. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_vf_handle_from_vf_index(amdsmi_processor_handle processor_handle, uint32_t fcn_idx, amdsmi_vf_handle_t *vf_handle);

/**
 *  @brief Returns the handle of a virtual function from the given UUID
 *
 *  @param[in] uuid Function UUID to query.
 *
 *  @param[out] vf_handle Reference to the VF handle.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_vf_handle_from_uuid(const char *uuid, amdsmi_vf_handle_t *vf_handle);

/**
 *  @brief Returns the processor handle from the given UUID
 *
 *  @param[in] uuid Function UUID to query.
 *
 *  @param[out] processor_handle Reference to the processor handle.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_processor_handle_from_uuid(const char *uuid, amdsmi_processor_handle *processor_handle);

/**
 *  @brief Returns the UUID of the processor
 *
 *  @param[in] processor_handle PF for which to query
 *
 *  @param[inout] uuid_length Length of the uuid string. As inpout, must be
 *  equal or greater than AMDSMI_GPU_UUID_SIZE and be allocated by
 *  user. As output it is the length of the uuid string.
 *
 *  @param[out] uuid Pointer to string to store the UUID. Must be
 *  allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_device_uuid(amdsmi_processor_handle processor_handle, unsigned int *uuid_length, char *uuid);

/**
 *  @brief Returns the UUID of the VF
 *
 *  @param[in] processor_handle VF for which to query
 *
 *  @param[inout] uuid_length Length of the uuid string. As inpout, must be
 *  equal or greater than AMDSMI_GPU_UUID_SIZE and be allocated by
 *  user. As output it is the length of the uuid string.
 *
 *  @param[out] uuid Pointer to string to store the UUID. Must be
 *  allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_vf_uuid(amdsmi_vf_handle_t processor_handle, unsigned int *uuid_length, char *uuid);
/** @} */  // end of discovery

/*****************************************************************************/
/** @defgroup swversion SW Version Information
 *  @{
 */

/**
 *  @brief          Returns the driver version information
 *
 *  @param[in]      processor_handle Device which to query
 *
 *  @param[out]     info Reference to driver information structure. Must be
 *                  allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_driver_info(amdsmi_processor_handle processor_handle, amdsmi_driver_info_t *info);

/**
 *  @brief          Returns the driver model information
 *
 *  @param[in]      processor_handle Device which to query
 *
 *  @param[out]     model Reference to the enum representing driver model.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_driver_model(amdsmi_processor_handle processor_handle, amdsmi_driver_model_type_t *model);

/**
 *  @brief Get the build version information for the currently running build of
 *  AMDSMI.
 *
 *
 *  @details  Get the major, minor, release string for AMDSMI build
 *  currently in use through @p version
 *
 *  @param[in,out] version A pointer to an ::amdsmi_version_t structure that will
 *  be updated with the version information upon return.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_lib_version(amdsmi_version_t *version);
/** @} */  // end of swversion

/*****************************************************************************/
/** @defgroup asicinfo ASIC & Board Static Information
 *  @{
 */

/**
 *  @brief Returns the ASIC information for the processor.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to static asic information structure.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_asic_info(amdsmi_processor_handle processor_handle, amdsmi_asic_info_t *info);

/**
 *  @brief Returns vram info
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to vram info structure
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_vram_info(amdsmi_processor_handle processor_handle, amdsmi_vram_info_t *info);

/**
 *  @brief Returns the power caps as currently configured in the
 *  system.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.
 *  If a processor has more than one sensor, it could be greater than 0.
 *  Parameter @p sensor_ind is unused on @platform{host}.
 *
 *  @param[out] info Reference to power caps information structure. Must be
 *  allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_power_cap_info(amdsmi_processor_handle processor_handle, uint32_t sensor_ind, amdsmi_power_cap_info_t *info);

/**
 *  @brief Returns the PCIe info for the GPU.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to the PCIe information
 *  returned by the library. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_pcie_info(amdsmi_processor_handle processor_handle, amdsmi_pcie_info_t *info);

/**
 *  @brief Returns the framebuffer info for the ASIC.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to framebuffer info.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_fb_layout(amdsmi_processor_handle processor_handle, amdsmi_pf_fb_info_t *info);

/** @} */  // end of asicinfo

/*****************************************************************************/
/** @defgroup fwinfo Firmware & VBIOS queries
 *  @{
 */

/**
 *  @brief Returns the static information for the vBIOS on the processor.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to static vBIOS information.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_vbios_info(amdsmi_processor_handle processor_handle, amdsmi_vbios_info_t *info);

/**
 *  @brief Returns the board part number and board information for the requested processor
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to board info structure.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_board_info(amdsmi_processor_handle processor_handle, amdsmi_board_info_t *info);

/**
 *  @brief Returns the firmware versions running on PF of the processor.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to the fw info. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_fw_info(amdsmi_processor_handle processor_handle, amdsmi_fw_info_t *info);

/**
 *  @brief Gets firmware error records
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] records reference to the error records structure.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_fw_error_records(amdsmi_processor_handle processor_handle, amdsmi_fw_error_record_t *records);

/**
 *  @brief Returns the DFC fw table.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to the dfc fw info. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_dfc_fw_table(amdsmi_processor_handle processor_handle, amdsmi_dfc_fw_t *info);

/** @} */  // end of fwinfo

/*****************************************************************************/
/** @defgroup gpumon GPU Monitoring
 *  @{
 */

/**
 *  @brief Returns the current usage of the GPU engines (GFX, MM and MEM).
 *  Each usage is reported as a percentage from 0-100%.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info Reference to the gpu engine usage structure. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_activity(amdsmi_processor_handle processor_handle, amdsmi_engine_usage_t *info);

/**
 *  @brief Returns the current power and voltage of the GPU.
 *
 *  @note amdsmi_power_info_t::socket_power metric can rarely spike above the socket power limit in some cases
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.
 *  If a processor has more than one sensor, it could be greater than 0.
 *  Parameter @p sensor_ind is unused on @platform{host}.
 *
 *  @param[out] info Reference to the gpu power structure. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_power_info(amdsmi_processor_handle processor_handle, uint32_t sensor_ind, amdsmi_power_info_t *info);

/**
 *  @brief Sets GPU power cap.
 *
 *  @platform{host} @platform{gpu_bm_linux}
 *
 *  @details Set the power cap to the provided value @p cap.
 *  @p cap must be between the minimum (min_power_cap) and maximum (max_power_cap) power cap values,
 *  which can be obtained from ::amdsmi_power_cap_info_t.
 *
 *  @param[in] processor_handle processor handle
 *
 *  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.
 *  If a processor has more than one sensor, it could be greater than 0.
 *  Parameter @p sensor_ind is unused on @platform{host}.
 *
 *  @param[in] cap value representing power cap to set
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_set_power_cap(amdsmi_processor_handle processor_handle, uint32_t sensor_ind, uint64_t cap);

/**
 *  @brief Returns is power management enabled
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] enabled Reference to bool. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_is_gpu_power_management_enabled(amdsmi_processor_handle processor_handle, bool *enabled);

/**
 *  @brief Returns the measurements of the clocks in the GPU
 *  for the GFX and multimedia engines and Memory. This call
 *  reports the averages over 1s in MHz.
 *  For clk_type AMDSMI_CLK_TYPE_GFX cur_clk is expected to be larger than max_clk in some
 *  cases due to decoupled nature of master vs slave oscillator in DFLL
 *  clk_locked supported only for AMDSMI_CLK_TYPE_GFX
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] clk_type Enum representing the clock type to query.
 *
 *  @param[out] info Reference to the gpu clock structure.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_clock_info(amdsmi_processor_handle processor_handle, amdsmi_clk_type_t clk_type, amdsmi_clk_info_t *info);

/**
 *  @brief Returns temperature measurements of the GPU.
 *  The results are in C.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] sensor_type Enum representing GPU sensor to query.
 *
 *  @param[in] metric Enum representing the temperature metric to query (min, max, etc.)
 *
 *  @param[out] temperature Reference to the current, limit or shutdown temperature measured (depending on the metric parameter)
 *  Current temp is obtained for metric=AMDSMI_TEMP_CURRENT
 *  Limit temp is obtained for metric=AMDSMI_TEMP_CRITICAL
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_temp_metric(amdsmi_processor_handle processor_handle, amdsmi_temperature_type_t sensor_type,
										amdsmi_temperature_metric_t metric, int64_t *temperature);

/**
 *  @brief Returns gpu cache info.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] info reference to the cache info struct.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_cache_info(amdsmi_processor_handle processor_handle, amdsmi_gpu_cache_info_t *info);

/**
 *  @brief Returns metrics information
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[inout] metrics_size As input, the size of the provided buffer.
 *  As output, number of metrics in the buffer.
 *  Parameter must be allocated by user.
 *
 *  @param[out] metrics Reference to list of metrics returned by
 *  the library. Buffer must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_metrics(amdsmi_processor_handle processor_handle, uint32_t *metrics_size,
					amdsmi_metric_t *metrics);

/**
 * @brief Returns the soc pstate policy for the processor
 *
 * @platform{gpu_bm_linux} @platform{guest_1vf} @platform{host}
 *
 * @details Given a processor handle @p processor_handle, this function will write
 * current soc pstate  policy settings to @p policy. All the processors at the same socket
 * will have the same policy.
 *
 *  @param[in] processor_handle a processor handle
 *
 *  @param[out] policy the soc pstate  policy for this processor.
 *  If this parameter is nullptr, this function will return
 *  ::AMDSMI_STATUS_INVAL
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_soc_pstate(amdsmi_processor_handle processor_handle,
					amdsmi_dpm_policy_t *policy);

/**
 * @brief Set the soc pstate policy for the processor
 *
 * @platform{gpu_bm_linux} @platform{guest_1vf} @platform{host}
 *
 * @details Given a processor handle @p processor_handle and a soc pstate  policy @p policy_id,
 * this function will set the soc pstate  policy for this processor. All the processors at
 * the same socket will be set to the same policy.
 *
 *  @param[in] processor_handle a processor handle
 *
 *  @param[in] policy_id the soc pstate  policy id to set. The id is the id in
 *  amdsmi_dpm_policy_entry_t, which can be obtained by calling
 *  amdsmi_get_soc_pstate()
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_set_soc_pstate(amdsmi_processor_handle processor_handle,
					uint32_t policy_id);

/** @} */  // end of gpumon

/*****************************************************************************/
/** @defgroup eccinfo ECC information
 *  @{
 */

/**
 *  @brief Returns the number of ECC errors (correctable,
 *  uncorrectable and deferred) in the given GPU.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] ec Reference to error count structure. Count of ecc uncorrectable and
 *  correctable errors since last time driver was loaded. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_total_ecc_count(amdsmi_processor_handle processor_handle, amdsmi_error_count_t *ec);

/**
 *  @brief Returns the number of ECC errors (correctable,
 *  uncorrectable and deferred) for the given GPU block.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] block The block for which error counts should be retrieved
 *
 *  @param[out] ec Reference to error count structure. Count of ecc uncorrectable and
 *  correctable errors since last time driver was loaded. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_ecc_count(amdsmi_processor_handle processor_handle, amdsmi_gpu_block_t block, amdsmi_error_count_t *ec);

/**
 *  @brief Returns the enabled ECC bitmask.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in,out] enabled_blocks Bitmask of the enabled gpu blocks. Blocks are listed in amdsmi_gpu_block_t enum.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_ecc_enabled(amdsmi_processor_handle processor_handle, uint64_t *enabled_blocks);

/**
 *  @brief Returns the bad page info.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[inout] bad_page_size As input, the size of the provided buffer.
 *  As output, number of bad pages in the buffer.
 *  Parameter must be allocated by user.
 *
 *  @param[out] bad_pages Reference to list of bad pages returned by
 *  the library. Buffer must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_bad_page_info(amdsmi_processor_handle processor_handle, uint32_t *bad_page_size,
					amdsmi_eeprom_table_record_t *bad_pages);

/**
 *  @brief Returns RAS features info.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] ras_feature RAS features that are currently enabled and supported on
 *  the processor. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_gpu_ras_feature_info(amdsmi_processor_handle processor_handle, amdsmi_ras_feature_t *ras_feature);


/** @} */  // end of eccinfo

/*****************************************************************************/
/** @defgroup fbpart VF and FB partitioning queries
 *  @{
 */

/**
 *  @brief Returns the number of VFs enabled by gpuv in the ASIC.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] num_vf_enabled Reference to number of VF enabled. Must be
 *  allocated by user.
 *
 *  @param[out] num_vf_supported Reference to number of VF supported. Must be
 *  allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_num_vf(amdsmi_processor_handle processor_handle, uint32_t *num_vf_enabled, uint32_t *num_vf_supported);


/**
 *  @brief Enable a given number of VF.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] num_vf - Number of VFs to enable.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_set_num_vf(amdsmi_processor_handle processor_handle, uint32_t num_vf);

/**
 *  @brief Returns the current framebuffer partitioning structure as
 *  currently configured by the driver.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] vf_buffer_num Size of the buffer where the library will
 *  copy the data in units of VF
 *
 *  @param[out] info Reference to structure with the current partitioning
 *  information. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_vf_partition_info(amdsmi_processor_handle processor_handle, unsigned int vf_buffer_num,
				  amdsmi_partition_info_t *info);

/** @} */  // end of fbpart

/*****************************************************************************/
/** @defgroup vfconf VF Configuration
 *  @{
 */

/**
 *  @brief Returns the configuration structure for a VF.
 *
 *  @param[in] vf_handle Handle of the VF to query.
 *
 *  @param[out] config Reference to structure with the current VF
 *  configuration. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_vf_info(amdsmi_vf_handle_t vf_handle, amdsmi_vf_info_t *config);

/**
 *  @brief Returns the data structure for a VF.
 *
 *  @param[in] vf_handle Handle of the PF or VF to query.
 *
 *  @param[out] info Reference to structure with the current VF
 *  data. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_vf_data(amdsmi_vf_handle_t vf_handle, amdsmi_vf_data_t *info);

/** @} */  // end of vfconf

/*****************************************************************************/
/** @defgroup eventmon Event Monitoring
 *  @{
 */

/**
 *  @brief Allocate a new event set notifier to monitor different
 *  types of issues with the GPU running virtualization SW.
 *  This call registers an event set. The user must pass an array
 *  with the GPUs it wants to monitor with the selected event flags.
 *
 *  @param[in] processor_list Processor handles for the GPU to listen for events.
 *
 *  @param[in] num_devices Number of processors in the list.
 *
 *  @param[in] event_types Bitmask of the different event_types
 *  that the event_set will monitor in this GPU.
 *  Bit index (from 0):
 *  | 63 62 61 60| 59 .......... 0 |
 *  | event severity | event category bit field |
 *
 *  There are 5 event severities and the appropriate macros to set them:
 *  0b0000 High severity - AMDSMI_MASK_HIGH_ERROR_SEVERITY_ONLY
 *  0b0001 Med severity - AMDSMI_MASK_INCLUDE_MED_ERROR_SEVERITY
 *  0b0010 Low severity - AMDSMI_MASK_INCLUDE_LOW_ERROR_SEVERITY
 *  0b0100 Warn severity - AMDSMI_MASK_INCLUDE_WARN_SEVERITY
 *  0b1000 Info severity - AMDSMI_MASK_INCLUDE_INFO_SEVERITY
 *
 *  AMDSMI_MASK_INCLUDE_CATEGORY macro is used to set the category we want
 *  to monitor. Enum AMDSMI_EVENT_CATEGORY is used as the input parameter of the macro.
 *
 *  @param[out] set Reference to the pointer to the event set created
 *  by the library. This will be allocated by the library.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_event_create(amdsmi_processor_handle *processor_list, uint32_t num_devices,
					uint64_t event_types, amdsmi_event_set *set);

/**
 *  @brief The call blocks till timeout is expired to copy one event
 *  specified by the event set into the user provided
 *  notifier storage.
 *
 *  @note If timeout_usec is negative, the call will block forever,
 *  if timeout_usec is zero, the call returns immediately.
 *  Timeout value given in microseconds is converted to milliseconds.
 *  Minimal timeout is 1000 us. If provided timeout is lower than 1000
 *  then the timeout will be set to 1000us by default.
 *  The timeout value in us will be converted to a smaller integer value in ms.
 *  (e.g. 1500us -> 1ms , 2600us -> 2ms)
 *
 *  @note Provided event entry contains a 64 bit timestamp, fields for the category
 *  of the error, the sub-code and flags associated with the error, VF
 *  and GPU handles that originated the error and a 256B text buffer
 *  with a human-readable description of the error.
 *
 *  @param[in] set Event set to read from. Use the same variable set that was used
 *  in the ::amdsmi_event_create call.
 *
 *  @param[in] timeout_usec Timeout in usec to wait for event
 *
 *  @param[out] event Reference to the user allocated event notifier.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_event_read(amdsmi_event_set set, int64_t timeout_usec, amdsmi_event_entry_t *event);

/**
 *  @brief Destroys and frees an event set.
 *
 *  @param[in] set Event set to destroy.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_event_destroy(amdsmi_event_set set);

/** @} */  // end of eventmon

/*****************************************************************************/
/** @defgroup hostguest Host-Guest Interaction
 *  @{
 */

/**
 *  @brief Returns guest OS information of the queried VF. The fw_info
 *  field from the amdsmi_guest_data structure is deprecated and will be
 *  empty. To get the vf fw info, amdsmi_get_vf_fw_info API
 *  should be used.
 *
 *  @param[in] vf_handle Handle of the VF to query.
 *
 *  @param[out] info reference to the guest_data structure.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_guest_data(amdsmi_vf_handle_t vf_handle, amdsmi_guest_data_t *info);

/**
 *  @brief Returns the firmware versions running on a VF.
 *  In case the VM is not started on the VF,
 *  empty list will be returned and num_fw_info will be set to zero.
 *
 *  @param[in] vf_handle VF handle of a processor for which to query
 *
 *  @param[out] info Reference to the fw info. Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_vf_fw_info(amdsmi_vf_handle_t vf_handle, amdsmi_fw_info_t *info);

/**
 *  @brief Return the list of supported profiles on the given GPU device.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] profile_info reference to the profile info struct.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_partition_profile_info(amdsmi_processor_handle processor_handle,
				       amdsmi_profile_info_t *profile_info);

/** @} */  // end of hostguest

/*****************************************************************************/
/** @defgroup link XGMI info
 *  @{
 */

/**
 *  @brief Return link metric information
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] link_metrics reference to the link metrics struct.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_link_metrics(amdsmi_processor_handle processor_handle,
					amdsmi_link_metrics_t *link_metrics);

/**
 *  @brief Return link topology information between two connected processors
 *
 *  @param[in] processor_handle_src Source PF of a processor for which to query
 *
 *  @param[in] processor_handle_dst Destination PF of a processor for which to query
 *
 *  @param[out] topology_info reference to the link topology struct.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_link_topology(amdsmi_processor_handle processor_handle_src,
					 amdsmi_processor_handle processor_handle_dst,
					 amdsmi_link_topology_t *topology_info);

/**
 *  @brief          Retrieve the set of GPUs that are nearest to a given device
 *                  at a specific interconnectivity level.
 *
 *  @platform{gpu_bm_linux}  @platform{host}
 *
 *  @details        Once called topology_nearest_info will get populated with a list of
 *                  all nearest devices for a given link_type. The list has a count of
 *                  the number of devices found and their respective handles/identifiers.
 *
 *  @param[in]      processor_handle The identifier of the given device.
 *
 *  @param[in]      link_type The amdsmi_link_type_t level to search for nearest GPUs.
 *
 *  @param[in,out]  topology_nearest_info
 *                  .count;
 *                    - When zero, is set to the number of matching GPUs such that .processor_list can
 *                    be malloc'd.
 *                    - When non-zero, .processor_list will be filled with count number of processor_handle.
 *
 *  @param[out]     .processor_list An array of processor_handle for GPUs found at level.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail.
 */
amdsmi_status_t amdsmi_get_link_topology_nearest(amdsmi_processor_handle processor_handle,
						amdsmi_link_type_t link_type,
						amdsmi_topology_nearest_t *topology_nearest_info);

/**
 *  @brief Return XGMI capabilities
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] caps reference to the xgmi caps union.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_xgmi_fb_sharing_caps(amdsmi_processor_handle processor_handle,
						amdsmi_xgmi_fb_sharing_caps_t *caps);

/**
 *  @brief Return XGMI framebuffer sharing information between two GPUs
 *
 *  @param[in] processor_handle_src Source PF of a processor for which to query
 *
 *  @param[in] processor_handle_dst Destination PF of a processor for which to query
 *
 *  @param[in] mode Enum representing the framebuffer sharing mode to query
 *
 *  @param[out] fb_sharing Indicates framebuffer sharing between two processors.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_get_xgmi_fb_sharing_mode_info(amdsmi_processor_handle processor_handle_src,
						     amdsmi_processor_handle processor_handle_dst,
						     amdsmi_xgmi_fb_sharing_mode_t mode,
						     uint8_t *fb_sharing);

/**
 *  @brief Set XGMI framebuffer sharing mode.
 *
 *  @note This API will only work if there's no guest VM running.
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] mode Enum representing the framebuffer sharing mode to set
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_set_xgmi_fb_sharing_mode(amdsmi_processor_handle processor_handle,
						amdsmi_xgmi_fb_sharing_mode_t mode);

/**
 *  @brief Set XGMI framebuffer custom sharing mode.
 *
 *  @note This API will only work if there's no guest VM running.
 *        This api can be used for custom and auto setting of xgmi frame buffer sharing.
 *        In case of custom mode:
 *          - All processors in the list must be on the same NUMA node.
 *            Otherwise, api will return error.
 *          - If any processor from the list already belongs to an existing group,
 *            the existing group will be released automatically.
 *        In case of auto mode(MODE_X):
 *          - The input parameters num_processors should be 1 and processor_list[0] should be valid.
 *            Only the first element of processor_list is taken into account and it can be any gpu0,gpu1,...
 *
 *  @param[in] processor_list The list of processors
 *
 *  @param[in] num_processors The number of processors in the list
 *
 *  @param[in] mode Enum representing the framebuffer sharing mode to set
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_set_xgmi_fb_sharing_mode_v2(amdsmi_processor_handle *processor_list, uint32_t num_processors,
						amdsmi_xgmi_fb_sharing_mode_t mode);


/**
 *  @brief Retrieve connection type and P2P capabilities between 2 GPUs
 *
 *  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf}  @platform{guest_mvf}
 *
 *  @details Given a source processor handle @p processor_handle_src and
 *  a destination processor handle @p processor_handle_dst, a pointer to an amdsmi_link_type_t @p type,
 *  and a pointer to amdsmi_p2p_capability_t @p cap. This function will write the connection type,
 *  and io link capabilities between the device
 *  @p processor_handle_src and @p processor_handle_dst to the memory
 *  pointed to by @p cap and @p type.
 *
 *  @param[in] processor_handle_src the source processor handle
 *
 *  @param[in] processor_handle_dst the destination processor handle
 *
 *  @param[in,out] type A pointer to an ::amdsmi_link_type_t to which the
 *  type for the connection should be written.
 *
 *  @param[in,out] cap A pointer to an ::amdsmi_p2p_capability_t to which the
 *  io link capabilities should be written.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_topo_get_p2p_status(amdsmi_processor_handle processor_handle_src,
                           amdsmi_processor_handle processor_handle_dst,
                           amdsmi_link_type_t *type, amdsmi_p2p_capability_t *cap);



/** @} */  // end of xgmi

/*****************************************************************************/
/** @defgroup vfmanagement VF management
 *  @{
 */

/**
 *  @brief Clear the framebuffer of a VF. If trying to clear the framebuffer
 *         of an active function, the call will fail with device busy.
 *
 *  @param[in] vf_handle - Handle to the VF to send the command to.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_clear_vf_fb(amdsmi_vf_handle_t vf_handle);
/** @} */  // end of vfmanagement

/**
 *  @brief Get a description of a provided AMDSMI error status
 *
 * @platform{gpu_bm_linux}  @platform{host} @platform{cpu_bm}  @platform{guest_1vf}  @platform{guest_mvf}
 *
 *  @details Set the provided pointer to a const char *, @p status_string, to
 *  a string containing a description of the provided error code @p status.
 *
 *  @param[in] status The error status for which a description is desired
 *
 *  @param[in,out] status_string A pointer to a const char * which will be made
 *  to point to a description of the provided error code
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t amdsmi_status_code_to_string(amdsmi_status_t status, const char **status_string);

/*****************************************************************************/
/** @defgroup Partitioning
 *  @{
 */

/**
 *  @brief Returns current gpu memory partition config and mode capabilities
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] config reference to the memory partition config.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
 amdsmi_status_t
 amdsmi_get_gpu_memory_partition_config(amdsmi_processor_handle processor_handle,
						amdsmi_memory_partition_config_t *config);

/**
 *  @brief Sets memory partition mode
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in] mode Enum representing memory partitioning mode to set
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_set_gpu_memory_partition_mode(amdsmi_processor_handle processor_handle, amdsmi_memory_partition_type_t mode);

/**
 *  @brief Returns gpu accelerator partition caps as currently configured in the system
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] profile_config reference to the accelerator partition config.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_gpu_accelerator_partition_profile_config(amdsmi_processor_handle processor_handle,
								amdsmi_accelerator_partition_profile_config_t *profile_config);

/**
 *  @brief Returns current gpu accelerator partition cap
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[out] profile reference to the accelerator partition profile.
 *  Must be allocated by user.
*
 *  @param[out] partition_id array of ids for current accelerator profile.
 *  Must be allocated by user.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_gpu_accelerator_partition_profile(amdsmi_processor_handle processor_handle,
			amdsmi_accelerator_partition_profile_t *profile, uint32_t *partition_id);

/**
 *  @brief Sets accelerator partition setting based on profile_index from amdsmi_get_gpu_accelerator_partition_profile_config
 *
 *  @param[in] processor_handle PF of a processor for which to query
 *
 *  @param[in]  profile_index Represents index of a partition user wants to set
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_set_gpu_accelerator_partition_profile(amdsmi_processor_handle processor_handle, uint32_t profile_index);

/** @} */  // end of partitioning


/**
 * @brief Retrieve CPER entries cached in the driver.
 *
 * The user will pass buffers to hold the CPER data and CPER headers. The library will
 * fill the buffer based on the severity_mask user passed. It will also parse the CPER header
 * and stored in the cper_hdrs array. The user can use the cper_hdrs to get the timestamp and other header information.
 * A cursor is also returned to the user, which can be used to get the next set of CPER entries.
 *
 * If there are more data than any of the buffers user pass, the library will return AMDSMI_STATUS_MORE_DATA.
 * User can call the API again with the cursor returned at previous call to get more data.
 * If the buffer size is too small to even hold one entry, the library
 * will return AMDSMI_STATUS_OUT_OF_RESOURCES.
 *
 * Even if the API returns AMDSMI_STATUS_MORE_DATA, the 2nd call may still get the entry_count == 0 as the driver
 * cache may not contain the serverity user is interested in. The API should return AMDSMI_STATUS_SUCCESS in this case
 * so that user can ignore that call.
 *
 * @param[in] processor_handle Handle to the processor for which CPER entries are to be retrieved.
 * @param[in] severity_mask The severity mask of the entries to be retrieved.
 * @param[in,out] cper_data Pointer to a buffer where the CPER data will be stored. User must allocate the buffer
 *                and set the buf_size correctly.
 * @param[in,out] buf_size Pointer to a variable that specifies the size of the cper_data.
 *                         On return, it will contain the actual size of the data written to the cper_data.
 * @param[in,out] cper_hdrs Array of the parsed headers of the cper_data. The user must allocate
 *             the array of pointers to cper_hdr. The library will fill the array with the pointers to the parsed
 *            headers. The underlying data is in the cper_data buffer and only pointer is stored in this array.
 * @param[in,out] entry_count Pointer to a variable that specifies the array length of the cper_hdrs user allocated.
 *              On return, it will contain the actual entries written to the cper_hdrs.
 * @param[in,out] cursor Pointer to a variable that will contain the  cursor  for the next call.
 *
 *  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail
 */
amdsmi_status_t
amdsmi_get_gpu_cper_entries(amdsmi_processor_handle processor_handle, uint32_t severity_mask, char *cper_data,
	uint64_t *buf_size, amdsmi_cper_hdr_t** cper_hdrs, uint64_t *entry_count, uint64_t *cursor);

#endif // __AMDSMI_H__
